<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring学习二]]></title>
    <url>%2F2019%2F05%2F30%2Fspring%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Spring好处经过昨天的练习学会了使用spring进行IOC，那么今天来思考一下，spring解决了什么问题，又有什么优势呢？ 先来看下一段jdbc程序12345678910//注册驱动DriverManager.registerDriver(new com.mysql.jdbc.Driver());//创建连接Connection connectMySQL = DriverManager.getConnection(“jdbc:mysql://localhost:3306/myuser","root" ,"123" );//获取操作数据库的预处理对象Statement statamentMySQL = connectMySQL.createStatement(); //获得返回结果statement.excuteUpdate( "INSERT INTO student(name, age, sex,address, depart, worklen,wage)" + " VALUES ('Tom1', 321, 'M', 'china','Personnel','3','3000' ) ") ; //释放资源 conn.close(); 那么这段程序有什么问题呢？在第二行的位置注册驱动时，因为直接使用了DriverManager.registerDriver如果程序中没有mysql的包将会直接产生检查型error进行报错。此时类之间的耦合性很高，那么如何能降低依赖呢？解耦的思路： 使用反射来创建对象，而避免使用关键字new； 通过读取配置文件来获取要创建的对象全限定类名； 其实还有一种驱动加载的方式是使用反射 Class.forName(“com.mysql.jdbc.Driver”) ``` 来代替注册驱动的位置，在程序编译时Class.forName参数中的只是字符串并不会产生报错，只有在运行时加载类的时候才会因找不到该类产生异常，由此来降低程序间的依赖。实际开发过程中也应该做到在编译期不依赖，运行时才依赖。12345在传统方式使用中mvc时，使用的是通过接口 = new 具体实现类的方式获得具体对象,并执行方法，这的强依赖和上面的jdbc样例是一样的。```java Car car = new Bus();car.run(); 那么如何能解决眼前的问题呢？工厂模式解耦12345678910111213141516171819202122232425262728//工厂接口public interface Product &#123; void produce();&#125;//汽车接口public class Car implements Product &#123; @Override public void produce() &#123; System.out.println("***制造小汽车***"); &#125;&#125;//电视接口public class Tv implements Product&#123; @Override public void produce() &#123; System.out.println("***制造电视***"); &#125;&#125;//工厂类public static Product produce(String name) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Product product = (Product)Class.forName(className).newInstance(); return product;&#125;//测试类 public static void main(String[] args) &#123; BeanFactory.produce("com.impl.Car").produce(); BeanFactory.produce("com.impl.Tv").produce(); &#125; 执行结果：制造小汽车制造电视Process finished with exit code 0 使用此模式在使用时参数还是需要准确的写出包的路径，并且每次反射都是新建了一个新的对象，在非多线程环境下对资源的消耗是一种浪费。由此对此程序进行优化 创建一个Bean对象工厂 需要一个配置文件来配置加载项( 配置内容：唯一标识 = 全限定类名（KEY ，Value）) 通过读取配置文件中配置的内容，反射创建对象 配置文件既可以是xml 也可以是properties 12345678910111213141516171819202122232425262728293031323334353637383940public class BeanFactory &#123; private static Properties props ; //定义一个map用来存放需要的对象，模拟容器 private static Map&lt;String,Object&gt; beans; //类加载时读取配置文件并加载到容器中 static &#123; InputStream in = null; beans = new HashMap(); props = new Properties(); try &#123; //为防止加载时路径异常使用类加载器获取路径 in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties"); props.load(in); Iterator&lt;String&gt; iterator = props.stringPropertyNames().iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); String value = props.getProperty(key); Object bean = Class.forName(value).newInstance(); beans.put(key, bean); &#125; &#125; catch (IOException e) &#123; throw new ExceptionInInitializerError("初始化失败"); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != in) in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static Product produce(String name) throws ClassNotFoundException,IllegalAccessException, InstantiationException &#123; return (Product) beans.get(name); &#125;&#125; bean.properties内容：12tv=com.impl.Tvcar=com.impl.Car 通过以上方式来模拟了一个容器，实现了应用对资源的解耦，而使用了spring的IOC则完全避免了去实现这些复杂的处理，优雅的实现。”不要给我们打电话，我们会打给你的。”这是著名的好莱坞原则。早先传统的方式通过new 关键字主动创建一个依赖的对象，使用了spring后只需要告诉它需要什么类，剩下的交给它搞定，于是控制反转了Inversion of Control 简称IOC。]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习一 IOC、DI]]></title>
    <url>%2F2019%2F05%2F28%2FSpring%E5%AD%A6%E4%B9%A0%E4%B8%80-IOC%E3%80%81DI%2F</url>
    <content type="text"><![CDATA[IOC、DI项目地址基于配置文件的练习1.准备pojo123456789101112131415161718package com.how2java.pojo;public class Category &#123; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private int id; private String name;&#125; 2.配置文件在src目录下新建applicationContext.xml文件applicationContext.xml是Spring的核心配置文件，通过关键字c即可获取Category对象，该对象获取的时候，即被注入了字符串”category 1“到name属性中12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注入对象1.准备pojo1234567891011121314151617181920212223242526package com.how2java.pojo;public class Product &#123; private int id; private String name; private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 2.在applicationContext.xml中注入对象123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.how2java.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt; &lt;property name="category" ref="c" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注解的方式 IOC、DI1.配置applicationContext.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:annotation-config/&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.how2java.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt;&lt;!-- &lt;property name="category" ref="c" /&gt; --&gt; &lt;/bean&gt;&lt;/beans&gt; 2.pojo中加入注解@Autowired1234567891011121314151617181920212223242526package com.how2java.pojo;import org.springframework.beans.factory.annotation.Autowired;public class Product &#123; private int id; private String name; @Autowired private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 除了在属性前加上@Autowired 这种方式外，也可以在setCategory方法前加上@Autowired，这样来达到相同的效果除了@Autowired之外，也可以使用@Resource@Resource和@Autowired注解都是用来实现依赖注入的。只是@Autowired按byType自动注入，而@Resource默认按 byName自动注入。@Resource有两个重要的属性，分是name和type。Spring将name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 在配置了两个bean后使用Autowired因为有两个bean没法指定所以报错，此时可以使用@Resource 来指定加载name是c2那个bean1234567891011//@Resource(name ="c2") @Autowired private Category category; public Category getCategory() &#123; return category; &#125; 错误提示 Could not autowire. There is more than one bean of 'Category' type. Beans: c (applicationContext.xml) c2 (applicationContext.xml) 对Bean的注解1.配置applicationContext.xml只保留]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSO 单点登陆]]></title>
    <url>%2F2019%2F05%2F26%2FSSO-%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[起源在一个企业发展的过程中，用到的系统会慢慢增多，使用人员在多个系统中操作时需要登录各个系统，而且可能每个系统账号都不一样，这对使用人员来说很不方便，于是就产生了单点登录，在一个系统登录其他的系统就不用登陆。 实现过程在做单点登录之前先来回顾下单系统登录的操作，首先进入系统登录页面，填写登录信息提交表单，系统后台对账号密码进行验证，验证通过就会建立Session ，然后把sessionid通过cookie发送给浏览器，下次再请求系统时cookie会跟着发送过去，此时就已经知道该账号已经登陆了。 那么既然系统A已经登录认证过了，是不是再请求别的系统B时也就认证通过了呢？首先要解决的是session共享问题，系统A认证登录过后在服务器中建立了一个session对应的当前会话，并把sessionId放到了cookie中返回给了浏览器，系统B显然是没有系统A的session的，此时可以使用Redis 把session缓存其中多个系统都共用。 session的问题解决了那么前端的cookie呢？浏览器请求系统A获得的cookie 是不能跨域请求到系统中B的。cookie不能跨域，那么我们可以把这两个系统放到同一域名下，分为不同的二级域名。比如www.abc.OA.com 和www.abc.HR.com 它们的父级域名 www.abc.com。 但是考虑到多个系统架构不同，语言也可能不同，共享session 有点麻烦，且如果是不同域呢？有没有更好的方式呢？此时引入正题，就是由耶鲁大学提出的CAS（Central Authentication Service）一个著名的SSO解决方案。流程如下： 用户访问A系统，验证此用户未登陆。 重定向至cas，cas中也没有登陆，返回登陆页面 填写用户名、密码，cas进行认证后，产生一个Ticket（随机字符串认证用的）将登录状态写入cas的session，返回给浏览器cas下的Cookie，并将将Ticket放入URL中返回（如：www.a.com/pageA?ticket=123） 浏览器被重定向请求系统A，系统A拿着ticket去cas验证是否是伪造的，cas认证通过，在cas中注册系统A创建全局会话，并通知系统A验证通过。 系统A建立session，返回给浏览器系统A的cookie，并把浏览器请求的页面返回。 再次访问A系统另一个受限页面时因为浏览器中已携带该域cookie，则直接返回资源给浏览器。 验证后系统B登陆流程如下： 补充 CAS的SSO实现方式可简化理解为：1个Cookie和N个Session。CAS Server创建cookie，在所有应用认证时使用，各应用通过创建各自的Session来标识用户是否已登录。 ST（Service Ticket） 1、 ST只能使用一次CAS协议规定，无论 Service Ticket验证是否成功， CAS Server都会清除服务端缓存中的该Ticket，从而可以确保一个Service Ticket不被使用两次。 2、 ST在一段时间内失效CAS规定ST只能存活一定的时间，然后CAS Server会让它失效。默认有效时间为5分钟。 3、 ST是基于随机数生成的ST必须足够随机，如果ST生成规则被猜出，Hacker就等于绕过CAS认证，直接访问对应的服务。 码农翻身读后感]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>单点登陆</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2019%2F05%2F26%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[什么是Hexo ?Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。 准备工作相关资料Github 官网Github PagesHexo 官网Node.js 官网Git 官网 相关教程使用 GitHub 和 Hexo 搭建免费静态 Blog简书 搭建个人博客知乎主题配置 常用命令依照上面的连接把准备工作做完了之后来使用下面命令开始博客之旅。 12345678910111213npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客命令简写hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 Markdown 格式 添加标签title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: web前端tags: jQuery 表格 表单验证设置以后点击对应的标签均可连接到当前文章内。 添加文章分类title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: web前端如果在 web前端下方添加-xx 不会产生两个分类，会产生层级的分类，嵌套在上一级分类下。个性化定制添加网易云音乐打开网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器 复制外链的代码修改 blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码 设置背景把你挑选的背景图片命名为：background.jpg，放在blog\themes\next\source\images里，在blog\themes\next\source\css_custom文件的custom.styl首部添加：1234body &#123; background:url(/images/background.jpg); background-attachment: fixed;&#125; background-attachment: fixed;是固定背景图片。 ###踩过的坑域名失效问题每次在执行命令hexo g -d （先生成文件再部署）时，都会使设置好的域名失效。因此需要在生成静态资源的目录（blog/public）底下新建CNAME文件（无后缀名）在其中配置上域名即可。 添加评论，页面不显示关于评论，我选择的是来必力思密达的插件，在配置时Next主题文档提示只需要在主题配置gentie_productKey 配置上来必力的id即可。但是在实际操作时发现页面并没有显示评论窗口，在查看配置文件时（next\layout_partials\comments.swig）发现，加载思密达的插件逻辑是如果没有多说，多言或等等等且gentie_productKey不为空则加载插件，考虑到可能中间可能有哪个评论的配置没有注释掉而没有加载，这里直接偷懒把判断加载思密达插件的逻辑放到了判断的前面，hexo clean、hexo g -d 至此评论区显示成功。配置文件如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% if page.comments %&#125; &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &lt;div class="comments" id="comments"&gt; &lt;div class="ds-thread" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.facebook_sdk.enable and theme.facebook_comments_plugin.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div class="fb-comments" data-href="&#123;&#123; page.permalink &#125;&#125;" data-numposts="&#123;&#123; theme.facebook_comments_plugin.num_of_posts &#125;&#125;" data-width="&#123;&#123; theme.facebook_comments_plugin.width &#125;&#125;" data-colorscheme="&#123;&#123; theme.facebook_comments_plugin.scheme &#125;&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.vkontakte_api.enable and theme.vkontakte_api.comments %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="vk_comments"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.disqus.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="disqus_thread"&gt; &lt;noscript&gt; Please enable JavaScript to view the &lt;a href="https://disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt; &lt;/noscript&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.hypercomments_id %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="hypercomments_widget"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.youyan_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="uyan_frame"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="SOHUCS"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.gitment.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表（中）]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[如何设计一个工业级的散列函数？何为一个工业级的散列表？工业级的散列表应该具有哪些特性？1.支持快速的查询、插入、删除操作； 2.内存占用合理，不能浪费过多空间； 3.性能稳定，散列函数生成的值要尽可能的均匀分布，在极端情况下，散列表的性能也不会退化到无法接受的情况。 方案：如何设计这样一个散列表呢？根据前面的知识点，从3个方面来考虑设计思路： 1.设计一个不复杂，散列值尽可能分布均匀的散列函数； 2.定义装载因子阈值，并且设计高效动态扩容策略； 3.选择合适的散列冲突解决方法。 步骤拆分： 一、如何设计散列函数？1.要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。2.除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。3.常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。 二、如何根据装载因子动态扩容？1.如何设置装载因子阈值？ 装载因子越大，说明散列表中的元素越多，空闲的位置就越少，冲突的概率就越大，对于动态的散列表，可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，创建一个更大的散列表将数据迁移到新散列表中,如果每次扩容都是原来大小的两倍，那么扩容后的负载因子就会降为原来的一半。（插入数据的时间复杂度使用摊还分析法，均摊复杂度O(1)） 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。 2.如何避免低效扩容？大部分情况下散列表插入一个数据都很快，但是当负载因子到达阀值，需要进行扩容，再插入数据，再扩容的过程中因为散列表大小进行了改变所以存储的位置也得到了改变，这个时候插入数据就会变得很慢。 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。 分批扩容的查询操作：先查新散列表，再查老散列表。 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。 三、如何选择散列冲突解决方法？常见的2中方法：开放寻址法和链表法。1.链表法对内存的空间利用率更高，链表节点可以在冲突时再创建，并不需要开放寻址法提前将空间申请好。其对大装载因子的容忍度更高。开放寻址适用于装载因子小于1的情景，接近1的时候，就会出现大量的散列冲突，导致大量探测，再散列，性能会下降很多。但是对于链表法来说只要散列函数值均匀，即使装载因子变成了10，也只是链表的长度拉长了，虽然查找效率变慢，但是比顺序查找还是要快很多。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。 2.开放寻址法可以利用CPU缓存加快查询速度但是删除数据比较麻烦，并不能直接删除，需要标记已经删除掉的数据，而且每个冲突的数据都在数组中，冲突的代价很高，装载因子也不能设置的过大，导致了此方法比较浪费内存空间。但是对于小规模数据、装载因子不高的散列表，比较适合用。 四、总结基于链表的散列冲突方法比较适合存储大对象，大数据量的散列表，因为对于大对象而言散列表中存储的指针大小基本可以忽略了，对于比较小的对象存储，是比较消耗内存的。但是比起开放寻址法它更加的灵活，支持更多的优化策略，比如红黑树代替链表。 举例分析1.初始大小Java中的HashMap的默认初始大小是16，可以在预先知道大小时修改默认配置，减少扩容次数。2.装载因子和动态扩容最大装载因子默认是0.75，当元素个数超过了 0.75 * size 的时候，就会启动扩容，每次扩容是原来的两倍。3.散列冲突解决方法HashMap底层使用链表法来解决冲突，负载因子和散列函数设计的再合理也会出现拉链过场的情况，严重影响HashMap的性能。在JDK1.8版本中，引入了红黑树。当链表长度太长（默认为8）时，链表就转化为红黑树。利用红黑树快速增删改查的特点提高性能，在红黑树节点少于8个的时候又将红黑树转化为链表。（在数据量矫情的情况下，红黑树要维护平衡，和链表比起来性能上没什么优势）4.散列函数1234int hash(Object key) &#123; int h = key.hashCode()； return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); //capicity 表示散列表的大小&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表（上）]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、散列表的由来？1.散列表又称Hash Table ,平时也叫它“哈希表”。散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。2.需要存储在散列表中的数据我们称为(key)，将key转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。3.将数据存储在散列值对应的数组下标位置。 二、如何设计散列函数？散列函数的三个基本要求： 1.散列函数计算得到的散列值是一个非负整数。 2.若key1=key2，则hash(key1)=hash(key2) 3.若key≠key2，则hash(key1)≠hash(key2) 对于第三点，在实际场景中因为鸽笼效应（既21只鸽子，20个鸽笼肯定有一个鸽笼有两只鸽子）对应代码问题是数组的大小有限，比如常见的哈希算法取模法。数组的长度是5，这时有一个数据是6。那么如何把这个6存放到长度只有5的数组中呢？按照取模法，计算6％5，结果是1，那么就把6放到数组下标是1的位置。所以在数组大小受限的情况下散列冲突是必然产生的。 三、散列冲突的解放方法？那么既然散列冲突无法避免如何去解决散列冲突呢？常用的散列冲突解决方法有2类：开放寻址法（open addressing）和链表法（chaining） 1.开放寻址法核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。 线性探测法（Linear Probing）：插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到空闲位置，将其插入。查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。删除数据：在查找时如果元素为空则表示不在散列表中，为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。极端情况下需要遍历整个数组所以最坏时间复杂度为O(n) 二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。 双重散列（Double hashing）：不使用一个散列函数而是使用一组散列函数（hash1(),hash2()），先用第一个散列函数，如果得到的存储位置被占用则使用第二个，依次类推，直到找到空闲位置为止。 不管使用什么方法，当散列表空闲位置不多时，散列冲突概率就会很高，为了保证散列表的操作效率，一般情况都会保证散列表有一定比例的空位在此用“装载因子”来表示空位多少。 散列表装载因子=填入表中的个数/散列表的长度。 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 2.链表法（常用）插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。 四、思考1.Word文档中单词拼写检查功能是如何实现的？字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。 2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？遍历 10 万条数据，以 URL 为 key，访问次数为value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果k的数值不大，可使用桶排序，时间复杂度为O(n),如果K的数值较大，就使用快排，时间复杂度为O(NlogN) 3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？先将第一个字符串数组构建一个散列表，key为字符串value为次数。再以第二个字符串数组的值为key遍历，值相同的value+1，最后value大于1的说明有相同字符串。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
