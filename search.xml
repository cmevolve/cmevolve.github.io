<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[散列表（中）]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[如何设计一个工业级的散列函数？何为一个工业级的散列表？工业级的散列表应该具有哪些特性？1.支持快速的查询、插入、删除操作； 2.内存占用合理，不能浪费过多空间； 3.性能稳定，散列函数生成的值要尽可能的均匀分布，在极端情况下，散列表的性能也不会退化到无法接受的情况。 方案：如何设计这样一个散列表呢？根据前面的知识点，从3个方面来考虑设计思路： 1.设计一个不复杂，散列值尽可能分布均匀的散列函数； 2.定义装载因子阈值，并且设计高效动态扩容策略； 3.选择合适的散列冲突解决方法。 步骤拆分： 一、如何设计散列函数？1.要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。2.除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。3.常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。 二、如何根据装载因子动态扩容？1.如何设置装载因子阈值？ 装载因子越大，说明散列表中的元素越多，空闲的位置就越少，冲突的概率就越大，对于动态的散列表，可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，创建一个更大的散列表将数据迁移到新散列表中,如果每次扩容都是原来大小的两倍，那么扩容后的负载因子就会降为原来的一半。（插入数据的时间复杂度使用摊还分析法，均摊复杂度O(1)） 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。 2.如何避免低效扩容？大部分情况下散列表插入一个数据都很快，但是当负载因子到达阀值，需要进行扩容，再插入数据，再扩容的过程中因为散列表大小进行了改变所以存储的位置也得到了改变，这个时候插入数据就会变得很慢。 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。 分批扩容的查询操作：先查新散列表，再查老散列表。 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。 三、如何选择散列冲突解决方法？常见的2中方法：开放寻址法和链表法。1.链表法对内存的空间利用率更高，链表节点可以在冲突时再创建，并不需要开放寻址法提前将空间申请好。其对大装载因子的容忍度更高。开放寻址适用于装载因子小于1的情景，接近1的时候，就会出现大量的散列冲突，导致大量探测，再散列，性能会下降很多。但是对于链表法来说只要散列函数值均匀，即使装载因子变成了10，也只是链表的长度拉长了，虽然查找效率变慢，但是比顺序查找还是要快很多。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。 2.开放寻址法可以利用CPU缓存加快查询速度但是删除数据比较麻烦，并不能直接删除，需要标记已经删除掉的数据，而且每个冲突的数据都在数组中，冲突的代价很高，装载因子也不能设置的过大，导致了此方法比较浪费内存空间。但是对于小规模数据、装载因子不高的散列表，比较适合用。 四、总结基于链表的散列冲突方法比较适合存储大对象，大数据量的散列表，因为对于大对象而言散列表中存储的指针大小基本可以忽略了，对于比较小的对象存储，是比较消耗内存的。但是比起开放寻址法它更加的灵活，支持更多的优化策略，比如红黑树代替链表。 举例分析1.初始大小Java中的HashMap的默认初始大小是16，可以在预先知道大小时修改默认配置，减少扩容次数。2.装载因子和动态扩容最大装载因子默认是0.75，当元素个数超过了 0.75 * size 的时候，就会启动扩容，每次扩容是原来的两倍。3.散列冲突解决方法HashMap底层使用链表法来解决冲突，负载因子和散列函数设计的再合理也会出现拉链过场的情况，严重影响HashMap的性能。在JDK1.8版本中，引入了红黑树。当链表长度太长（默认为8）时，链表就转化为红黑树。利用红黑树快速增删改查的特点提高性能，在红黑树节点少于8个的时候又将红黑树转化为链表。（在数据量矫情的情况下，红黑树要维护平衡，和链表比起来性能上没什么优势）4.散列函数1234int hash(Object key) &#123; int h = key.hashCode()； return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); //capicity 表示散列表的大小&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表（上）]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、散列表的由来？1.散列表又称Hash Table ,平时也叫它“哈希表”。散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。2.需要存储在散列表中的数据我们称为(key)，将key转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。3.将数据存储在散列值对应的数组下标位置。 二、如何设计散列函数？散列函数的三个基本要求： 1.散列函数计算得到的散列值是一个非负整数。 2.若key1=key2，则hash(key1)=hash(key2) 3.若key≠key2，则hash(key1)≠hash(key2) 对于第三点，在实际场景中因为鸽笼效应（既21只鸽子，20个鸽笼肯定有一个鸽笼有两只鸽子）对应代码问题是数组的大小有限，比如常见的哈希算法取模法。数组的长度是5，这时有一个数据是6。那么如何把这个6存放到长度只有5的数组中呢？按照取模法，计算6％5，结果是1，那么就把6放到数组下标是1的位置。所以在数组大小受限的情况下散列冲突是必然产生的。 三、散列冲突的解放方法？那么既然散列冲突无法避免如何去解决散列冲突呢？常用的散列冲突解决方法有2类：开放寻址法（open addressing）和链表法（chaining） 1.开放寻址法核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。 线性探测法（Linear Probing）：插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到空闲位置，将其插入。查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。删除数据：在查找时如果元素为空则表示不在散列表中，为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。极端情况下需要遍历整个数组所以最坏时间复杂度为O(n) 二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。 双重散列（Double hashing）：不使用一个散列函数而是使用一组散列函数（hash1(),hash2()），先用第一个散列函数，如果得到的存储位置被占用则使用第二个，依次类推，直到找到空闲位置为止。 不管使用什么方法，当散列表空闲位置不多时，散列冲突概率就会很高，为了保证散列表的操作效率，一般情况都会保证散列表有一定比例的空位在此用“装载因子”来表示空位多少。 散列表装载因子=填入表中的个数/散列表的长度。 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 2.链表法（常用）插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。 四、思考1.Word文档中单词拼写检查功能是如何实现的？字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。 2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？遍历 10 万条数据，以 URL 为 key，访问次数为value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果k的数值不大，可使用桶排序，时间复杂度为O(n),如果K的数值较大，就使用快排，时间复杂度为O(NlogN) 3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？先将第一个字符串数组构建一个散列表，key为字符串value为次数。再以第二个字符串数组的值为key遍历，值相同的value+1，最后value大于1的说明有相同字符串。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
