<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring学习九-AOP]]></title>
    <url>%2F2019%2F06%2F30%2FSpring%E5%AD%A6%E4%B9%A0%E4%B9%9D-AOP%2F</url>
    <content type="text"><![CDATA[AOP概念1.什么是AOP？AOP：全称是 Aspect Oriented Programming 即：面向切面编程。简单来说AOP就是在程序中将重复的代码提取出来，在需要的时候，通过预编译方式运行时动态代理实现在不修改源代码的情况下，对已有的方法进行增强。 2.Spring AOP代理机制1.若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。 优点：因为有接口，所以使系统更加松耦合 缺点：为每一个目标类创建接口 2、若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。 优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。 缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。 3.相关术语Joinpoint( 连接点):所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。Pointcut( 切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。Advice( 通知/ 增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction( 引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或 Field。Target( 目标对象):代理的目标对象。Weaving( 织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。Proxy （代理）:一个类被 AOP 织入增强后，就产生一个结果代理类。Aspect( 切面):是切入点和通知（引介）的结合。 4.AOP基于xml配置使用前要明确先编写完成核心业务代码，然后把公用的代码抽取出来，制作成通知，然后在配置文件中声明切入点与通知的关系，及切面。具体步骤如下： 把通知Bean也交给spring来管理 使用aop:config标签表明开始AOP的配置 使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定通知类bean的Id。 在aop:aspect标签的内部使用对应标签来配置通知的类型 aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 aop:after-returning :后置通知，切入点方法执行后执行 aop:after-throwing ：异常通知，切入点方法产生异常时通知 aop:after :最终通知，无论是否切入点方法异常都会通知类似 finally切入点表达式的写法：关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) 标准的表达式写法： public void com.itheima.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法： * *..*.*(..) 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.service.impl.*.*(..) Maven导入aspectj包 切入表达式 12345678&lt;dependencies&gt; &lt;!-- 切入点表达式配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; xml配置1234567891011121314151617181920212223 &lt;context:annotation-config/&gt; &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.springAll.service.impl.AccountServiceImpl&quot;/&gt; &lt;!-- 配置logger类 --&gt; &lt;bean id=&quot;logger&quot; class=&quot;com.springAll.Logger&quot;/&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;&lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- 配置通知类型，简历通知方法和切入方法的关联 --&gt; &lt;aop:before method=&quot;beforePrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after-returning method=&quot;afterPrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-returning&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method=&quot;errorPrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-throwing&gt; &lt;!-- 最终通知 --&gt; &lt;aop:after method=&quot;finallyPrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试代码1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:applicationContext.xml")public class SpringAopTest &#123; @Resource private IAccountService accountService; @Test public void xmlAopTest()&#123; accountService.saveAccount(); accountService.updateAccount(); &#125;&#125; 但是每个切面中都需要有一个pointcut标签 配置切入点表达式，有些繁琐，所以这里可以将表达式提出来单独用标签来表示。1234567&lt;!-- 配置切面 --&gt;&lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!-- 配置通知类型，简历通知方法和切入方法的关联 --&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="log"&gt;&lt;/aop:before&gt; pointcut-ref="log"&gt;&lt;/aop:after&gt; &lt;aop:pointcut id="log" expression="execution(* com.springAll.service.impl.*.*(..))"/&gt;&lt;/aop:aspect&gt; 将aop:pointcut标签写在aop:aspect内部时，只有当前的切面可以使用，此时可以将其放到aop:config标签下，让其他的切入点也可以使用。（注：一定要将配置放到引用文件之前，不然没法使用。）12345678910&lt;aop:config&gt; &lt;aop:pointcut id="log" expression="execution(* com.springAll.service.impl.*.*(..))"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!-- 配置通知类型，简历通知方法和切入方法的关联 --&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="log"&gt;&lt;/aop:before&gt; &lt;!-- 最终通知 --&gt; &lt;aop:after method="finallyPrintLog" pointcut-ref="log"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 在上面讲了后置通知，前置通知，异常通知，和最终通知，最后再来看环绕通知。12 &lt;!-- 环绕通知 --&gt;&lt;aop:around method="aroundPrintLog" pointcut-ref="log"/&gt; Spring框架提供了一个接口ProceedingJoinPoint，此接口有一个方法proceed（）。相当于明确调用切入点方法。该接口可以作为环绕通知的方法参数，在程序执行时，Spring框架会提供该接口实现供我们使用。123456789101112131415public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object returnVal = null; try &#123; Object obj[] = pjp.getArgs(); //得到方法执行所需的参数 System.out.println("===============Logger类记录开始日志================ 前置"); returnVal = pjp.proceed(); //切入点方法 System.out.println("===============Logger类记录开始日志================ 后置"); &#125; catch (Throwable throwable) &#123; System.out.println("===============Logger类记录开始日志================ 异常"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("===============Logger类记录开始日志================ 最终"); &#125; return returnVal;&#125; 以上流程就叫做环绕通知，既可以定制化的决定使用何种通知，且可以在其中决定是否调用目标方法！！！在前置等其他通知中是不可以的，只是在方法调用前后执行通知而已。 环绕通知也可以控制返回对象，既可以返回一个与目标对象方法完全不同的对象！ 5.AOP基于注解xml开启注解AOP的支持1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 添加 @Aspect 表示当前类为切面类使用 @Pointcut 来指定切入点表达式。（此注解需要引入jar包aspectjweaver 最好是1.8以后的，之前使用的1.5的使用注解时报错了，需注意）123456789101112131415161718192021222324252627282930313233343536373839404142@Component("logger")@Aspect//表示当前类是一个切面类public class Logger &#123; @Pointcut("execution(* com.springAll.service.impl.*.*(..))") private void pt1()&#123;&#125; /** * 用于打印日志切入点方法之前执行 */ // @Before("pt1()") public void beforePrintLog()&#123; System.out.println("===============Logger类记录开始日志================"); &#125; @AfterReturning("pt1()") public void afterPrintLog()&#123; System.out.println("===============Logger类记录结束日志================"); &#125; @AfterThrowing("pt1()") public void errorPrintLog()&#123; System.out.println("===============Logger类记录异常日志================"); &#125; @After("pt1()") public void finallyPrintLog()&#123; System.out.println("===============Logger类记录最终日志================"); &#125;//@Around("pt1()") public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object returnVal = null; try &#123; Object obj[] = pjp.getArgs(); //得到方法执行所需的参数 System.out.println("===============Logger类记录开始日志================ 前置"); returnVal = pjp.proceed(); //切入点方法 System.out.println("===============Logger类记录开始日志================ 后置"); &#125; catch (Throwable throwable) &#123; System.out.println("===============Logger类记录开始日志================ 异常"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("===============Logger类记录开始日志================ 最终"); &#125; return returnVal; &#125;&#125; 执行结果：1234===============Logger类记录开始日志================执行保存===============Logger类记录最终日志===============================Logger类记录结束日志================ 此时发现执行结果的顺序有些问题，最终日志竟然输出在了结束日志的前面，经查spring注解aop中存在调用顺序异常的问题，所以在实际开发中可以考虑使用xml配置的方式或者使用注解的环绕通知，因为具体调用顺序由程序决定，所以不会有此问题。 练习资源]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习八-之动态代理]]></title>
    <url>%2F2019%2F06%2F23%2FSpring%E5%AD%A6%E4%B9%A0%E5%85%AB-%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、问题来源在进行软件设计的时候往往会将一个大的系统按照业务模块拆分成一个个的低耦合、高内聚的模块，分而治之。如图：拆分后发现一些问题，这些问题是通用的，跨模块的。比如：1.日志：对执行某些操作分支判断时输出日志。2.安全：在执行某些操作前进行权限检查。3.事务：在方法开始前开始事务，方法结束时提交或者回滚事务。4.性能统计：统计某些方法的执行时间。以上这些属于非功能型需求，是多个业务模块都需要的，那么应该如何去写呢？ 1.常规解决方法1234567891011121314151617181920public class Command &#123; public void execute()&#123; Logger logger = Logger.getLogger(""); //1.记录日志 logger.info("XXXX"); //2.性能统计 Long startTime = System.nanoTime(); //3.权限检查 if(!user.hasPreviledge())&#123; //抛出异常阻断流程 &#125; //4.开始事务，进行增删改操作 ------业务代码------- //提交事务 commitTransaction(); Long endTime = System.nanoTime(); logger.info("xxxxx"); &#125;&#125; 上面的代码虽然解决了问题，但是使用起来十分不爽，日志、安全、性能、事务等代码都耦合到了业务代码中，使一个简单的业务逻辑模块代码都异常的复杂，且重复代码充斥在各个业务逻辑中。 那么如何解决解决痛点呢？ 1.设计模式：模版方法首先先来回顾下模版方法：模版模式是当不变的和可变的行为混在一起的时候通过把不变的行为提取到超类并且定义一个算法的骨架，去除子类中的重复代码，以此摆脱重复不变行为的纠缠。一堆啰嗦的话，还是看下具体实现：12345678910111213141516171819202122232425262728293031323334//定义超类模版公共部分public abstract class Command &#123; public void execute()&#123; Logger logger = Logger.getLogger(""); //1.记录日志 logger.info("XXXX"); //2.性能统计 Long startTime = System.nanoTime(); //3.权限检查 if(!user.hasPreviledge())&#123; //抛出异常阻断流程 &#125; //4.开始事务，进行增删改操作 //5.业务代码操作交由具体子类独自实现 doBusiness(); //提交事务 commitTransaction(); Long endTime = System.nanoTime(); logger.info("xxxxx"); &#125; //具体业务实现，交给对应模块的子类 public abstract void doBusiness();&#125;class PlaceOrderCommand extends Command&#123; public void doBusiness() &#123; //执行订单操作 &#125;&#125;class PaymentCommand extends Command&#123; public void doBusiness() &#123; //执行支付操作 &#125;&#125; OK，这样一来，代码看起来清爽了好多，各种无关业务的代码在子类中也不复存在了。调用也很简单，例如：12Command cmd = new PlaceOrderCommand();cmd.execute(); 总结：仔细观察可以发现，使用这个方法会导致超类会定义所有的操作，要执行哪些非功能性代码，以什么顺序，等等。子类只能默默接受，那么有没有什么方法可以让子类达到定制化的效果，比如只需要进行事务的支持，其他的不需要。 2.设计模式：装饰者模式内容复习：装饰者模式可以动态的给一个对象添加一些额外的职责，有效的区分类的核心职责就增加功能而言，装饰者模式比生成子类更加灵活。废话不多说，上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface Command &#123; public void execute();&#125;/** * 日志类 */public class LoggerDecorator implements Command &#123; Command cmd; public LoggerDecorator(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; Logger logger = Logger.getLogger(""); logger.info("记录日志start"); this.cmd.execute(); logger.info("记录日志end"); &#125;&#125;/** * 性能统计 */ class PerformanceDecorator implements Command &#123; Command cmd; public PerformanceDecorator(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; PerformanceUtil.startTimer(); this.cmd.execute(); PerformanceUtil.endTimer(); &#125;&#125;/** * 执行订单操作，具体业务代码 */class PlaceOrderDecorator implements Command &#123; Command cmd; public PlaceOrderDecorator(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; //执行支付 &#125;&#125; 现在就像递归一样层层调用，可以自由的决定让PlaceOrderDecorator可以选择打印日志或者性能统计等等。123Command cmd = new LoggerDecorator(new PerformanceDecorator(new PlaceOrderDecorator()));cmd.execute(); 如果只需要其中部分功能只需要实例化对应的模块即可，例如只需要订单操作时打印日志123Command cmd = new LoggerDecorator(new PlaceOrderDecorator());cmd.execute(); 总结：装饰者模式虽然可以通过装饰器灵活的使用各种方法，但是由此也带出了两个问题：1.一个处理日志/安全/事务/性能统计的类为什么要去实现业务接口呢？2.如果其他模块没有实现业务接口，但是想使用日志/安全/事务/性能统计等功能，那该怎么办呢？ 3.代理模式Ⅰ.介绍：为其他对象提供一种代理以此来控制这个对象的访问，使客户端不直接引用对象，很好的在客户端和目标对象之间起到中介的作用。 Ⅱ.适用场景： 远程代理，为一个对象在不同的地址空间提供局部代表。这样即使远程方法在服务器，但是本地调用其代理类，内部屏蔽了远程调用过程，对于客户端而言与本地方法无异。（如：webService） 虚拟代理，占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。（比如：HTML加载时，有很多图片，为了及时的响应页面，可以先将图片位置展示代理对象，待缓存完成时，再展示出来；当一个对象加载耗费资源很大时，利用虚拟代理，将那些耗费资源的操作直到具体使用时再加载，在此之前使用虚拟代理对象来代替。可达到资源重用，节省内存，以时间换空间。；参考浏览器加载可在因io阻塞导致对象加载缓慢的时候，结合多线程技术先行一步创建加载较快的代理对象，另起线程加载真实对象，先行返回代理对象，当调用真实对象时，此时资源可能已经加载完毕，以此来加快相应时间。） 安全代理, 也叫保护代理，用来控制真实对象访问时的权限，如果有必要的话，可以给不同调用者提供不同的权限。 智能指引,是指当调用真实对象时，代理处理另外一些事，比如记录对此对象的调用次数等。 了解了代理模式及使用场景后，此处我们使用其中的智能指引的这种场景，既在代理类中对被代理的类添加一些功能。 代码：1234567891011121314151617181920212223242526272829public interface Command &#123; public void execute();&#125;public class PlaceOrderDecorator implements Command &#123; public void execute() &#123; System.out.println("执行支付"); &#125;&#125;/** * 代理类 */ class CommandProxy implements Command &#123; Command cmd; public CommandProxy(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; System.out.println("记录日志start"); this.cmd.execute(); System.out.println("记录日志end"); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Command cmd = new CommandProxy(new PlaceOrderDecorator()); cmd.execute(); &#125;&#125; 总结： 1、代理模式可以在不修改初始类的前提下对其功能进行了增强。 2、接口中有多少方法，在proxy层就得实现多少方法，有多少方法就要开启和提交多少事务，代码繁琐复杂。 3、如果一个proxy实现了多个接口，如果其中的一个接口发生变化（添加了一个方法），那么proxy也要做改变。 4、静态代理模式并没有做到日志的重用 由此引出今天的主角，动态代理。 4.动态代理Ⅰ、JDK动态代理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class Interceptor implements InvocationHandler&#123; Transaction transaction; Object target; public Interceptor(Transaction transaction, Object target) &#123; this.transaction = transaction; this.target = target; &#125; /** * @param proxy 目标对象的代理类实例 * @param method 对应于在代理实例上调用接口方法的Method实例 * @param args 传入到代理实例上方法参数值的对象数组 * @return 方法的返回值，没有返回值是null * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); if("execute".equals(methodName))&#123; transaction.beginTransaction(); method.invoke(target); transaction.commit(); &#125;else&#123; method.invoke(target); &#125; return null; &#125;&#125;/** * 事务类 */class Transaction&#123; void beginTransaction()&#123; System.out.println("******** 开启事务 **************"); &#125; void commit()&#123; System.out.println("********* 提交事务 ************"); &#125;&#125;/* * 测试类*/@Test public void testSave()&#123; /** * 1、创建一个目标对象 * 2、创建一个事务 * 3、创建一个拦截器 * 4、动态产生一个代理对象 */ Object target = new PlaceOrderDecorator(); Transaction transaction = new Transaction(); Interceptor proxy = new Interceptor(transaction,target); /** * 参数一：设置代码使用的类加载器，一般采用跟目标类相同的类加载器 * 参数二：设置代理类实现的接口，跟目标类使用相同的接口 * 参数三：设置回调对象，当代理对象的方法被调用时，会调用该参数指定对象的invoke方法 */ Command com = (Command) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(),proxy); com.execute(); &#125; 基于上述流程进行优化：12345678910111213141516171819202122232425262728293031323334public class ProxyFactory &#123; Transaction transaction = new Transaction(); Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; /** * 生成代理类 */ public Object getProxyInstance ()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); if("execute".equals(methodName))&#123; transaction.beginTransaction(); method.invoke(target,args); transaction.commit(); &#125;else&#123; method.invoke(target); &#125; return null; &#125; &#125;); &#125;&#125; @Test public void testProxy()&#123; Object target = new PlaceOrderDecorator(); Command com = (Command)new ProxyFactory(target).getProxyInstance(); com.execute(); &#125; 总结：静态代理与动态代理的区别： 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件。 动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中。 特点： 因为使用了JDKProxy生成的代理类实现了接口，所以目标类中所有的方法在代理类中会有。 动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。 invoke方法中的三个参数可以访问目标类的被调用方法的API、被调用方法的参数、被调用方法的返回类型。 缺点： 1.在拦截器中除了能调用目标对象的目标方法之外功能比较单一。 2.在使用拦截器中的invoke方法的if判断语句进行功能增强的时候具体实施时因为要支持日志/安全/事务/性能统计等功能，if语句需要写很多，这无疑是个灾难。 Ⅰ、CGLIB动态代理123456789101112131415161718192021222324252627282930313233343536public class CglibProxyFactory implements MethodInterceptor&#123; private Object target; Transaction transaction; public CglibProxyFactory(Object target, Transaction transaction) &#123; this.target = target; this.transaction = transaction; &#125; public Object getProxyInstance()&#123; //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 拦截调用intercept函数 en.setCallback(this); //创建子类对象代理 return en.create(); &#125; public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; transaction.beginTransaction(); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); transaction.commit(); return null; &#125;&#125;//测试类 @Test public void testCGlibProxy()&#123; PlaceOrderDecorator target = new PlaceOrderDecorator(); System.out.println(target.getClass()); PlaceOrderDecorator proxy = (PlaceOrderDecorator)new CglibProxyFactory(target,new Transaction()) .getProxyInstance(); System.out.println(proxy.getClass()); proxy.execute(); &#125; 输出结果： 12345class PlaceOrderDecoratorclass PlaceOrderDecorator$$EnhancerByCGLIB$$640bbc4f******** 开启事务 **************执行支付********* 提交事务 ************ 总结：1.JDK动态代理需要目标对象和代理对象实现业务接口，拦截器需要实现InvocationHandler接口，其中invoke方法体中内容是具体代理对象方法体内容。2.CGlib代理的目标类不需要实现接口，代理类是目标类的子类，拦截器需要实现MethodInterceptor接口，其中重写intercept方法时，进行具体功能增强操作。但是因为cglib是依靠继承目标对象重写其方法，所以目标对象不得是final类！！！ 练习资源]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习七-Spring整合Junit的配置]]></title>
    <url>%2F2019%2F06%2F16%2FSpring%E5%AD%A6%E4%B9%A0%E4%B8%83-Spring%E6%95%B4%E5%90%88Junit%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[问题：在Junit测试时，在将通用的bean注入提到方法外面形成全局变量时，在运行测试类代码时，会无法注入bean对象。在Junit单元测试中，没有main方法也能执行，其实是因为Junit集成了一个main方法，该方法会判断当前测试类哪些方法使用了@Test注解，Junit会让有注解的方法执行，但是Junit不会探测是否使用了Spring框架，在执行方法时也不会读取配置文件创建Spring核心容器，所以在Junit中没有没有ioc容器就算写了Autowired注解，bean对象也没办法注入。 方法：Spring整合Junit的配置1.导入spring整合junit的配置2.使用junit提供的注解把原有的runner方法替换为Spring提供的@Runwith3.告知Spring运行器，spring和IOC创建是基于注解的还是xml配置的，描述文件位置。4.@ContextConfiguration locations：指定xml文件的位置，加上classpath关键字，标识在类路径下 classes：指定注解类所在的地址注：当使用spring5.x版本的时候，要求junit的版本必须是4.12及以上 123456789101112@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration(locations = "classpath:applicationContext.xml")@ContextConfiguration(classes = Car.class)public class SpringTest &#123; @Autowired private Car car; @Test public void testFindAll()&#123; car.produce(); System.out.println("收拾收拾"); &#125; 练习资源]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习六-注解IOC]]></title>
    <url>%2F2019%2F06%2F15%2FSpring%E5%AD%A6%E4%B9%A0%E5%85%AD-%E6%B3%A8%E8%A7%A3IOC%2F</url>
    <content type="text"><![CDATA[基本配置@Component 注解是用于创建bean对象的，但是只使用@Component注解是无法使用的，需要在配置文件中去声明，告知spring在创建容器时要扫描的包，配置所需要的标签不是在bean的约束中，而是一个mingcheng为context名称空间和约束中1&lt;context:component-scan base-package="com.how2java.pojo"/&gt; 且在beans的头信息中需要导入如下信息12xmlns:aop="http://www.springframework.org/schema/aop"xmlns:context="http://www.springframework.org/schema/context" 详解：用于创建bean对象的他们的作用就和xml配置文件中编写一个bean标签实现的功能是一样的@Component 作用：用于把当前的对象放入到spring容器中。 属性： value:用于指定bean的id，如果不写beanname默认是当前类名，首字母小写。 Controller：一般用于表现层 Service:一般用于业务层 Respository:一般用于持久层以上三个注解的作用和属性和Component是一样的，他们三个是用来提供明确的三层使用的注解，使结构更加清晰。 ###用于注入数据的作用相当于xml配置文件中的bean标签中写一个标签Autowired: 作用：自动按照类型注入，只要有容器中有唯一的一个bean对象类型和要注入的变量类型匹配就可以成功。 1. 如果没有匹配类型则产生异常 2. 如果被spring管理的有多个相同类型对象则按照参数去匹配beanid如果匹配到就成功加载，匹配不到则抛出异常 出现位置：可以是方法上也可以是变量上。（无需有set方法） Qualifier : 作用:按照名称注入，在给类成员注入时不得单独使用(需和Autowired搭配使用)，但是给参数注入时可以使用。 属性： value:用于指定注入bean的id. Resource 作用：直接按照bean的id注入，可以独立使用 属性：name：用于指定bean的id以上三个注入类型都只能注入bean类型的数据，基本类型和string类型无法注入，另外集合类型注入只能通过xml注入。 Value: 作用：用于注入基本类型和String类型的数据 属性： value:用于指定数据的值，它可以使用SpEL（srping的EL表达式） 写法：$｛表达式｝ 用于改变作用范围的Scope 作用：用于指定bean的作用范围 属性： value：指定范围的取值。常用取值：singleton prototype 声明周期相关PreDestroy 作用：指定销毁方法 PostConstruct 作用：指定初始化方法 利用配置类来代替xmlConfiguration 作用：指定当前类是一个配置类ComponentScan 作用：通过注释指定spring在创建容器时要扫描的包 属性： value：作用和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包路径。等同于在xml配置了：1&lt;context:component-scan base-package="com.how2java.pojo"/&gt; 1234@Configuration@ComponentScan(value = "com.how2java.pojo")public class SpringConfig &#123;&#125; Bean 作用：用于把当前方法的返回值放入到spring容器中。 属性： name：用于指定bean的id，不写时默认id是当前方法名。 细节：当使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找方式和Aturowired方式是一样的，如果类型一样且只有一个对象就注入。123456789101112131415161718@Configuration@ComponentScan(value = "com.how2java.pojo")public class SpringConfig &#123; @Bean(name ="c") public Category getCategory(Product p)&#123; return new Category(); &#125; @Bean(name = "p") @Scope("prototype")//多例对象 public Product getProduct()&#123; return new Product(); &#125;&#125;//测试类ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);Product d = (Product) context.getBean("p"); import 作用：用于导入其他的配置类 属性： value:用于指定其他配置类的字节码 当使用import的注解以后，有import的类就是父配置类，导入的类是子配置类。12345678910111213141516@Configuration@ComponentScan(value = "com.how2java.pojo")@Import(SpringBean.class)public class SpringConfig &#123;&#125;public class SpringBean &#123; @Bean(name ="c") public Category getCategory(Product p)&#123; return new Category(); &#125; @Bean(name = "p") @Scope("prototype") public Product getProduct()&#123; return new Product(); &#125;&#125; PropertySource 作用：指定Propertys文件的位置 属性： value:用于指定文件的名称和路径。 关键字：classpath： 表示类路径下123456789101112@Configuration@ComponentScan(value = "com.how2java.pojo")@Import(SpringBean.class)@PropertySource("classpath:config.properties")public class SpringConfig &#123;&#125;//使用方式el表达式 @Value("$&#123;product.name&#125;") private String name; @Value("$&#123;product.no&#125;") private String no;]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spirng学习五-依赖注入的几种方式]]></title>
    <url>%2F2019%2F06%2F10%2FSpirng%E5%AD%A6%E4%B9%A0%E4%BA%94-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在学习的第一天就跟着demo练习了一番spring依赖注入的具体操作，在接下来的几天对于为什么要这么做有了一定的认识，今天对于依赖注入的具体方式来进行一下细分。 一、构造函数注入通过构造函数来进行依赖关系的设定，默认是使用的无参构造，如果重写了构造函数改成带参数的而没有无参构造，直接使用如下注入会失败。12345678String name;Integer price;Date byDate;public Car(String name, Integer price, Date byDate) &#123; this.name = name; this.price = price; this.byDate = byDate;&#125; 1&lt;bean name="car" class="com.pojo.Car" &gt;&lt;/bean&gt; 运行后错误提示1Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'car' defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.pojo.Car]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.pojo.Car.&lt;init&gt;() 配置这个时候如果要使用构造器注入对应的属性应该使用标签constructor-arg来注入有参构造的参数。其中的属性如下： type:通过指定要注入数据的数据类型，该数据类型也是构造函数中某个参数的类型（同参数类型的参数会引起混乱） index:用于指定要注入数据给构造函数中指定索引位置的参数赋值，索引位置是从0开始。 name:用于指定给构造函数中指定名称的参数赋值（常用） 赋值类型： value:基本类型和String类型赋值 ref：用于指定其他的bean类型数据（交给spring管理的bean对象） 代码示例12345 &lt;bean name="car" class="com.pojo.Car" &gt; &lt;constructor-arg name="name" value="雷克萨斯"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="price" value="600000"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="byDate" value="2018-1-1"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 此处Integer类型直接使用value可以将写入的值进行转换，但是Date类型并不会进行转换。提示如下：1Could not convert argument value of type [java.lang.String] to required type [java.util.Date]: Failed to convert value of type 'java.lang.String' to required type 'java.util.Date' 正确的写法应该先配置一个日期对象然后使用ref引用改对象对其进行赋值。123456&lt;bean name="car" class="com.pojo.Car" &gt; &lt;constructor-arg name="name" value="雷克萨斯"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="price" value="600000"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="byDate" ref="newDate"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name="newDate" class="java.util.Date"&gt;&lt;/bean&gt; 总结：优势：获取对象时，注入必须的操作否则对象没法创建成功。弊端：改变了bean对象的实例化方式，如果创建对象用不到的数据，但是也必须提供。 方法注入（常用）配置标签：property位置：bean标签内部属性： name：用于指定注入时所调用的set方法名称（注意是set方法名称，与变量名无关） value:用于提供基本类型和String类型的数据 ref:用于指定其他的bean类型数据。（交给spring管理的bean对象） 代码示例1234567891011121314public class Car &#123; String name; Integer price; Date byDate; public void setName(String name) &#123; this.name = name; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125; public void setByDate(Date byDate) &#123; this.byDate = byDate; &#125;&#125; 调用set方法，使用默认无参构造函数。12345&lt;bean name="car" class="com.pojo.Car" &gt; &lt;property name="name" value="梅赛德斯"/&gt; &lt;property name="byDate" ref="newDate"/&gt; &lt;property name="price" value="1000000"/&gt;&lt;/bean&gt; 总结优势：创建对象时没有明确限制，可以直接使用默认的构造函数弊端：如果某个成员必须有值，获取对象时有可能set方法还没有执行。 复合类型注入对于参数是集合类型的注入方法 配置标签：还是使用的set注入的标签property位置：bean标签内部 代码示例123456789101112131415161718public class Car &#123; String[] strs; List list; Map map; Set set; public void setList(List list) &#123; this.list = list; &#125; public void setMap(Map map) &#123; this.map = map; &#125; public void setStrs(String[] strs) &#123; this.strs = strs; &#125;&#125; public void setSet(Set set) &#123; this.set = set; &#125; 1234567891011121314151617181920212223242526 &lt;bean name="car" class="com.pojo.Car" &gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="set"&gt; &lt;set&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="strs"&gt; &lt;array&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="no1" value="abc"&gt;&lt;/entry&gt; &lt;entry key="no2" value="qwe"&gt;&lt;/entry&gt; &lt;entry key="no3" value="zxc"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; 但是在使用时发现关于list 、set 、数组类型的时候因为数据结构类型的类似，标签使用同一个也是可以注入的。例：1234567891011121314151617181920212223242526&lt;bean name="car" class="com.pojo.Car" &gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="set"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="strs"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="no1" value="abc"&gt;&lt;/entry&gt; &lt;entry key="no2" value="qwe"&gt;&lt;/entry&gt; &lt;entry key="no3" value="zxc"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; 总结：关于集合类型的注入其实就分为两种一种是list（也可以使用set、array）、一种是map、props的键值类型，类型相同标签可以互换。]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spirng学习四-SpringBean的作用域]]></title>
    <url>%2F2019%2F06%2F09%2FSpirng%E5%AD%A6%E4%B9%A0%E5%9B%9B-SpringBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Bean注入的三种方式1：使用默认的构造函数在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时采用的就是默认的构造函数常见bean对象，此时如果没有默认构造函数则对象无法创建。1&lt;bean name="car" class="impl.Car"/&gt; 2.使用普通工厂的方法创建对象（使用某个类中的方法创建对象，交给spring管理）比如jar包中的class中某个方法创建了一个对象现在希望通过它来获得对象交给spring管理12345public class BeanFactory2 &#123; public Car getCar()&#123; return new Car(); &#125;&#125; 首先将该类交给Spring管理，之后通过beanName指定该类通过factory-method指定通过该类中getCar方法获得对象。12 &lt;bean name="factory" class="com.factory.BeanFactory2"&gt;&lt;/bean&gt;&lt;bean name="factoryCar" factory-bean="factory" factory-method="getCar"&gt;&lt;/bean&gt; 3.使用工厂中的静态方法创建对象基于上面的工厂方法获得对象，在工厂类的方法是static修饰的静态方法的时候可以直接通过如下配置加载。1&lt;bean name="factoryCar" class="com.factory.BeanFactory2" factory-method="getCar"&gt;&lt;/bean&gt; Bean的作用域在Spring容器中一共提供了五种作用域类型，在配置文件中通过属性scope来设置bean的作用域范围。 1.默认 singleton：单例1&lt;bean name="car" class="impl.Car" scope="singleton"/&gt; 在对scope没有设置的时候bean默认就是单例的，多次获取同一个id都是一个bean的实例。 1234//此时容器初始化完毕后可以取里面的bean了. Car car1 = (Car)bf.getBean("car"); Car car2 = (Car)bf.getBean("car"); System.out.println(car1 == car2); 执行结果：12小汽车被加载了true 2. prototype：多例]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习三-ApplicationContext]]></title>
    <url>%2F2019%2F06%2F05%2FSpring%E5%AD%A6%E4%B9%A0%E4%B8%89-ApplicationContext%2F</url>
    <content type="text"><![CDATA[Spring中的Resource接口 在Spring内部实现机制，针对于资源文件(配置的xml文件)有一个统一的接口Resource。 Resource具体实现类： ClassPathResource:类路径下的资源，位置在classes路径下 FileSystemResource:文件系统资源，资源以文件系统路径的方式表示，如：D:/File/conf.xml; InputStreamResource:对应一个InputStream的资源 ServletContextResource:访问web容器上下文中资源的类，负责以相对于web应用根目录的路径加载资源，支持以流和URL的方式访问。 UrlResource :用户能够访问任何可以通过URL表示的资源。如http资源，ftp资源。 Spring的资源类型的地址前缀地址前缀对应资源类型 classpath:从类路径中加载资源，相对于类的根路径。 file:使用URLResource从文件系统目录中装载资源。 http://：使用URLResource从web服务器中装载资源。 ftp://:使用URLResource从ftp服务器中装载资源。 无前缀：根据ApplicationContext具体实现类采用对应类型的Resource。在web项目中可以使用Resource 来代替java的IO来获取资源，并且还支持Ant通配符。Ant风格: ?:匹配文件名中的一个字符. *:匹配文件命中的任意字符. ** :匹配多层路径.示例：123456789101112131415161718192021PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; Resource[] res = resolver.getResources("classpath:/test.txt"); for (Resource resource : res)&#123; System.out.println(resource.getDescription()+"----"+resource.getFilename()); //System.out.println(resource.getFile().); BufferedReader bf = new BufferedReader(new FileReader(resource.getFile())); String data = ""; while((data = bf.readLine())!=null)&#123; System.out.println(data); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (null != bf)bf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 输出结果12class path resource [test.txt]----test.txtspringResource加载 BeanFactory和ApplicationContextBeanFactoryBeanFactory 是延迟加载，如果bean的某一属性没有注入，BeanFactory加载后，直到调用getBean方法的时候才会抛出异常，而ApplicationContext在初始化的时候会进行校验，这样有利于检查依赖的属性是否注入。且ApplicationContext继承自Beanfactory，其实现更为丰富，故通常我们选择使用ApplicationContext。初始化Beanfactory的例子：123456789101112//调用资源加载器加载Spring配置文件 PathMatchingResourcePatternResolver resolver=new PathMatchingResourcePatternResolver(); Resource res =resolver.getResource("classpath:/applicationContext.xml"); DefaultListableBeanFactory bf =new DefaultListableBeanFactory(); //BeanDefinition 读取器,专门读取资源到容器 XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(bf); //读取资源进到容器 reader.loadBeanDefinitions(res); //此时容器初始化完毕后可以取里面的bean了. bf.getBean("car"); ApplicationContext主要类和接口ApplicationEventPublisher: 让容器拥有发布应用程序上下文事件的功能.ResourcePatternResolver:实现了类似于资源加载器的功能，能够识别特定前缀加Ant风格的路径并加载到容器中.LifeCycle：管理容器中bean的生命周期。ConfigurableApplicationContext:主要新增了refresh()和close()方法，让ApplicationContext有用了启动，关系和刷新上下文的功能。ClassPathXmlApplicationContext与FileSystemXmlApplicationContext:Spring提供的两个常用的ApplicationContext实现类，前者默认从类路径加载配置文件，后者从文件系统加载。然后初始化一个ApplicationContext看看:12ApplicationContext ac =new ClassPathXmlApplicationContext("application.xml");ApplicationContext ac =new FileSystemXmlApplicationContext(/User/Desktop/application.xml); ClassPathXmlApplicationContext如果没有前缀默认就是classpath: FileSystemXmlApplicationContext如果没有前缀默认就是 file: Spring容器不仅可以通过xml来初始化，也可以通过@Configuration注解来注册Bean，Spring也提供了相应的AnnotationConfigApplicationContext。 1ApplicationContext context =new AnnotationConfigApplicationContext(Config.class); 其中Config类就是加了@Configuration的类. ###WebApplicationContextWebApplicationContext是Spring专门为web应用准备的，它可以从现对于web根目录的路径中装配文件来完成初始化。WebApplicationContext与ServletContext可以相互获得.在非Web应用的环境下，Bean只有singleton和prototype两种作用域，而WebApplicationContext为Bean添加了三个新的作用域:request,session,global session。 WebApplicationContext和ServletContext是如何相互获取的，其实很简单，在WebApplicationContext里有ServletContext成员变量，直接get就完了。在ServletContext里有一个写死的attrbute，也是直接get..而且Spring提供了一个WebApplicationContextUtils来封装了这个写死的attribute. 1234其实就是直接调用了ServletContext.getAttribute(ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123; return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); &#125; WebApplication的初始化初始化的方式有两种： 在web.xml中配置一个ContextLoaderListener； 配置一个自启动的LoaderServlet 12345678 &lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 不根据xml启动Spring而使用@Configuration类启动 123456789101112 &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.zdy.Configuration&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 配置一个contextClass参数ApplicationContext改为AnnotationConfigWebApplicationContext，然后contextConfigLocation不是指定配置文件xml位置了，改为指定Configuration类的位置。就OK了。 练习来源：我又不是架构师]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring学习二]]></title>
    <url>%2F2019%2F05%2F30%2Fspring%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Spring好处经过昨天的练习学会了使用spring进行IOC，那么今天来思考一下，spring解决了什么问题，又有什么优势呢？ 先来看下一段jdbc程序12345678910//注册驱动DriverManager.registerDriver(new com.mysql.jdbc.Driver());//创建连接Connection connectMySQL = DriverManager.getConnection(“jdbc:mysql://localhost:3306/myuser","root" ,"123" );//获取操作数据库的预处理对象Statement statamentMySQL = connectMySQL.createStatement(); //获得返回结果statement.excuteUpdate( "INSERT INTO student(name, age, sex,address, depart, worklen,wage)" + " VALUES ('Tom1', 321, 'M', 'china','Personnel','3','3000' ) ") ; //释放资源 conn.close(); 那么这段程序有什么问题呢？在第二行的位置注册驱动时，因为直接使用了DriverManager.registerDriver如果程序中没有mysql的包将会直接产生检查型error进行报错。此时类之间的耦合性很高，那么如何能降低依赖呢？解耦的思路： 使用反射来创建对象，而避免使用关键字new； 通过读取配置文件来获取要创建的对象全限定类名； 其实还有一种驱动加载的方式是使用反射 Class.forName(“com.mysql.jdbc.Driver”) ``` 来代替注册驱动的位置，在程序编译时Class.forName参数中的只是字符串并不会产生报错，只有在运行时加载类的时候才会因找不到该类产生异常，由此来降低程序间的依赖。实际开发过程中也应该做到在编译期不依赖，运行时才依赖。12345在传统方式使用中mvc时，使用的是通过接口 = new 具体实现类的方式获得具体对象,并执行方法，这的强依赖和上面的jdbc样例是一样的。```java Car car = new Bus();car.run(); 那么如何能解决眼前的问题呢？工厂模式解耦12345678910111213141516171819202122232425262728//工厂接口public interface Product &#123; void produce();&#125;//汽车接口public class Car implements Product &#123; @Override public void produce() &#123; System.out.println("***制造小汽车***"); &#125;&#125;//电视接口public class Tv implements Product&#123; @Override public void produce() &#123; System.out.println("***制造电视***"); &#125;&#125;//工厂类public static Product produce(String name) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Product product = (Product)Class.forName(className).newInstance(); return product;&#125;//测试类 public static void main(String[] args) &#123; BeanFactory.produce("com.impl.Car").produce(); BeanFactory.produce("com.impl.Tv").produce(); &#125; 执行结果：制造小汽车制造电视Process finished with exit code 0 使用此模式在使用时参数还是需要准确的写出包的路径，并且每次反射都是新建了一个新的对象，在非多线程环境下对资源的消耗是一种浪费。由此对此程序进行优化 创建一个Bean对象工厂 需要一个配置文件来配置加载项( 配置内容：唯一标识 = 全限定类名（KEY ，Value）) 通过读取配置文件中配置的内容，反射创建对象 配置文件既可以是xml 也可以是properties 12345678910111213141516171819202122232425262728293031323334353637383940public class BeanFactory &#123; private static Properties props ; //定义一个map用来存放需要的对象，模拟容器 private static Map&lt;String,Object&gt; beans; //类加载时读取配置文件并加载到容器中 static &#123; InputStream in = null; beans = new HashMap(); props = new Properties(); try &#123; //为防止加载时路径异常使用类加载器获取路径 in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties"); props.load(in); Iterator&lt;String&gt; iterator = props.stringPropertyNames().iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); String value = props.getProperty(key); Object bean = Class.forName(value).newInstance(); beans.put(key, bean); &#125; &#125; catch (IOException e) &#123; throw new ExceptionInInitializerError("初始化失败"); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != in) in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static Product produce(String name) throws ClassNotFoundException,IllegalAccessException, InstantiationException &#123; return (Product) beans.get(name); &#125;&#125; bean.properties内容：12tv=com.impl.Tvcar=com.impl.Car 通过以上方式来模拟了一个容器，实现了应用对资源的解耦，而使用了spring的IOC则完全避免了去实现这些复杂的处理，优雅的实现。”不要给我们打电话，我们会打给你的。”这是著名的好莱坞原则。早先传统的方式通过new 关键字主动创建一个依赖的对象，使用了spring后只需要告诉它需要什么类，剩下的交给它搞定，于是控制反转了Inversion of Control 简称IOC。 代码地址]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习一 IOC、DI]]></title>
    <url>%2F2019%2F05%2F28%2FSpring%E5%AD%A6%E4%B9%A0%E4%B8%80-IOC%E3%80%81DI%2F</url>
    <content type="text"><![CDATA[IOC、DI项目地址基于配置文件的练习1.准备pojo123456789101112131415161718package com.how2java.pojo;public class Category &#123; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private int id; private String name;&#125; 2.配置文件在src目录下新建applicationContext.xml文件applicationContext.xml是Spring的核心配置文件，通过关键字c即可获取Category对象，该对象获取的时候，即被注入了字符串”category 1“到name属性中12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注入对象1.准备pojo1234567891011121314151617181920212223242526package com.how2java.pojo;public class Product &#123; private int id; private String name; private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 2.在applicationContext.xml中注入对象123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.how2java.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt; &lt;property name="category" ref="c" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注解的方式 IOC、DI1.配置applicationContext.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:annotation-config/&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.how2java.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt;&lt;!-- &lt;property name="category" ref="c" /&gt; --&gt; &lt;/bean&gt;&lt;/beans&gt; 2.pojo中加入注解@Autowired1234567891011121314151617181920212223242526package com.how2java.pojo;import org.springframework.beans.factory.annotation.Autowired;public class Product &#123; private int id; private String name; @Autowired private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 除了在属性前加上@Autowired 这种方式外，也可以在setCategory方法前加上@Autowired，这样来达到相同的效果除了@Autowired之外，也可以使用@Resource@Resource和@Autowired注解都是用来实现依赖注入的。只是@Autowired按byType自动注入，而@Resource默认按 byName自动注入。@Resource有两个重要的属性，分是name和type。Spring将name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 在配置了两个bean后使用Autowired因为有两个bean没法指定所以报错，此时可以使用@Resource 来指定加载name是c2那个bean1234567891011//@Resource(name ="c2") @Autowired private Category category; public Category getCategory() &#123; return category; &#125; 错误提示 Could not autowire. There is more than one bean of 'Category' type. Beans: c (applicationContext.xml) c2 (applicationContext.xml) 对Bean的注解1.配置applicationContext.xml只保留]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSO 单点登陆]]></title>
    <url>%2F2019%2F05%2F26%2FSSO-%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[起源在一个企业发展的过程中，用到的系统会慢慢增多，使用人员在多个系统中操作时需要登录各个系统，而且可能每个系统账号都不一样，这对使用人员来说很不方便，于是就产生了单点登录，在一个系统登录其他的系统就不用登陆。 实现过程在做单点登录之前先来回顾下单系统登录的操作，首先进入系统登录页面，填写登录信息提交表单，系统后台对账号密码进行验证，验证通过就会建立Session ，然后把sessionid通过cookie发送给浏览器，下次再请求系统时cookie会跟着发送过去，此时就已经知道该账号已经登陆了。 那么既然系统A已经登录认证过了，是不是再请求别的系统B时也就认证通过了呢？首先要解决的是session共享问题，系统A认证登录过后在服务器中建立了一个session对应的当前会话，并把sessionId放到了cookie中返回给了浏览器，系统B显然是没有系统A的session的，此时可以使用Redis 把session缓存其中多个系统都共用。 session的问题解决了那么前端的cookie呢？浏览器请求系统A获得的cookie 是不能跨域请求到系统中B的。cookie不能跨域，那么我们可以把这两个系统放到同一域名下，分为不同的二级域名。比如www.abc.OA.com 和www.abc.HR.com 它们的父级域名 www.abc.com。 但是考虑到多个系统架构不同，语言也可能不同，共享session 有点麻烦，且如果是不同域呢？有没有更好的方式呢？此时引入正题，就是由耶鲁大学提出的CAS（Central Authentication Service）一个著名的SSO解决方案。流程如下： 用户访问A系统，验证此用户未登陆。 重定向至cas，cas中也没有登陆，返回登陆页面 填写用户名、密码，cas进行认证后，产生一个Ticket（随机字符串认证用的）将登录状态写入cas的session，返回给浏览器cas下的Cookie，并将将Ticket放入URL中返回（如：www.a.com/pageA?ticket=123） 浏览器被重定向请求系统A，系统A拿着ticket去cas验证是否是伪造的，cas认证通过，在cas中注册系统A创建全局会话，并通知系统A验证通过。 系统A建立session，返回给浏览器系统A的cookie，并把浏览器请求的页面返回。 再次访问A系统另一个受限页面时因为浏览器中已携带该域cookie，则直接返回资源给浏览器。 验证后系统B登陆流程如下： 补充 CAS的SSO实现方式可简化理解为：1个Cookie和N个Session。CAS Server创建cookie，在所有应用认证时使用，各应用通过创建各自的Session来标识用户是否已登录。 ST（Service Ticket） 1、 ST只能使用一次CAS协议规定，无论 Service Ticket验证是否成功， CAS Server都会清除服务端缓存中的该Ticket，从而可以确保一个Service Ticket不被使用两次。 2、 ST在一段时间内失效CAS规定ST只能存活一定的时间，然后CAS Server会让它失效。默认有效时间为5分钟。 3、 ST是基于随机数生成的ST必须足够随机，如果ST生成规则被猜出，Hacker就等于绕过CAS认证，直接访问对应的服务。 码农翻身读后感]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>单点登陆</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2019%2F05%2F26%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[什么是Hexo ?Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。 准备工作相关资料Github 官网Github PagesHexo 官网Node.js 官网Git 官网 相关教程使用 GitHub 和 Hexo 搭建免费静态 Blog简书 搭建个人博客知乎主题配置 常用命令依照上面的连接把准备工作做完了之后来使用下面命令开始博客之旅。 12345678910111213npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客命令简写hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 Markdown 格式 添加标签title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: web前端tags: jQuery 表格 表单验证设置以后点击对应的标签均可连接到当前文章内。 添加文章分类title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: web前端如果在 web前端下方添加-xx 不会产生两个分类，会产生层级的分类，嵌套在上一级分类下。个性化定制添加网易云音乐打开网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器 复制外链的代码修改 blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码 设置背景把你挑选的背景图片命名为：background.jpg，放在blog\themes\next\source\images里，在blog\themes\next\source\css_custom文件的custom.styl首部添加：1234body &#123; background:url(/images/background.jpg); background-attachment: fixed;&#125; background-attachment: fixed;是固定背景图片。 ###踩过的坑域名失效问题每次在执行命令hexo g -d （先生成文件再部署）时，都会使设置好的域名失效。因此需要在生成静态资源的目录（blog/public）底下新建CNAME文件（无后缀名）在其中配置上域名即可。 添加评论，页面不显示关于评论，我选择的是来必力思密达的插件，在配置时Next主题文档提示只需要在主题配置gentie_productKey 配置上来必力的id即可。但是在实际操作时发现页面并没有显示评论窗口，在查看配置文件时（next\layout_partials\comments.swig）发现，加载思密达的插件逻辑是如果没有多说，多言或等等等且gentie_productKey不为空则加载插件，考虑到可能中间可能有哪个评论的配置没有注释掉而没有加载，这里直接偷懒把判断加载思密达插件的逻辑放到了判断的前面，hexo clean、hexo g -d 至此评论区显示成功。配置文件如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% if page.comments %&#125; &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &lt;div class="comments" id="comments"&gt; &lt;div class="ds-thread" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.facebook_sdk.enable and theme.facebook_comments_plugin.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div class="fb-comments" data-href="&#123;&#123; page.permalink &#125;&#125;" data-numposts="&#123;&#123; theme.facebook_comments_plugin.num_of_posts &#125;&#125;" data-width="&#123;&#123; theme.facebook_comments_plugin.width &#125;&#125;" data-colorscheme="&#123;&#123; theme.facebook_comments_plugin.scheme &#125;&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.vkontakte_api.enable and theme.vkontakte_api.comments %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="vk_comments"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.disqus.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="disqus_thread"&gt; &lt;noscript&gt; Please enable JavaScript to view the &lt;a href="https://disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt; &lt;/noscript&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.hypercomments_id %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="hypercomments_widget"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.youyan_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="uyan_frame"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="SOHUCS"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.gitment.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表（中）]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[如何设计一个工业级的散列函数？何为一个工业级的散列表？工业级的散列表应该具有哪些特性？1.支持快速的查询、插入、删除操作； 2.内存占用合理，不能浪费过多空间； 3.性能稳定，散列函数生成的值要尽可能的均匀分布，在极端情况下，散列表的性能也不会退化到无法接受的情况。 方案：如何设计这样一个散列表呢？根据前面的知识点，从3个方面来考虑设计思路： 1.设计一个不复杂，散列值尽可能分布均匀的散列函数； 2.定义装载因子阈值，并且设计高效动态扩容策略； 3.选择合适的散列冲突解决方法。 步骤拆分： 一、如何设计散列函数？1.要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。2.除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。3.常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。 二、如何根据装载因子动态扩容？1.如何设置装载因子阈值？ 装载因子越大，说明散列表中的元素越多，空闲的位置就越少，冲突的概率就越大，对于动态的散列表，可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，创建一个更大的散列表将数据迁移到新散列表中,如果每次扩容都是原来大小的两倍，那么扩容后的负载因子就会降为原来的一半。（插入数据的时间复杂度使用摊还分析法，均摊复杂度O(1)） 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。 2.如何避免低效扩容？大部分情况下散列表插入一个数据都很快，但是当负载因子到达阀值，需要进行扩容，再插入数据，再扩容的过程中因为散列表大小进行了改变所以存储的位置也得到了改变，这个时候插入数据就会变得很慢。 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。 分批扩容的查询操作：先查新散列表，再查老散列表。 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。 三、如何选择散列冲突解决方法？常见的2中方法：开放寻址法和链表法。1.链表法对内存的空间利用率更高，链表节点可以在冲突时再创建，并不需要开放寻址法提前将空间申请好。其对大装载因子的容忍度更高。开放寻址适用于装载因子小于1的情景，接近1的时候，就会出现大量的散列冲突，导致大量探测，再散列，性能会下降很多。但是对于链表法来说只要散列函数值均匀，即使装载因子变成了10，也只是链表的长度拉长了，虽然查找效率变慢，但是比顺序查找还是要快很多。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。 2.开放寻址法可以利用CPU缓存加快查询速度但是删除数据比较麻烦，并不能直接删除，需要标记已经删除掉的数据，而且每个冲突的数据都在数组中，冲突的代价很高，装载因子也不能设置的过大，导致了此方法比较浪费内存空间。但是对于小规模数据、装载因子不高的散列表，比较适合用。 四、总结基于链表的散列冲突方法比较适合存储大对象，大数据量的散列表，因为对于大对象而言散列表中存储的指针大小基本可以忽略了，对于比较小的对象存储，是比较消耗内存的。但是比起开放寻址法它更加的灵活，支持更多的优化策略，比如红黑树代替链表。 举例分析1.初始大小Java中的HashMap的默认初始大小是16，可以在预先知道大小时修改默认配置，减少扩容次数。2.装载因子和动态扩容最大装载因子默认是0.75，当元素个数超过了 0.75 * size 的时候，就会启动扩容，每次扩容是原来的两倍。3.散列冲突解决方法HashMap底层使用链表法来解决冲突，负载因子和散列函数设计的再合理也会出现拉链过场的情况，严重影响HashMap的性能。在JDK1.8版本中，引入了红黑树。当链表长度太长（默认为8）时，链表就转化为红黑树。利用红黑树快速增删改查的特点提高性能，在红黑树节点少于8个的时候又将红黑树转化为链表。（在数据量矫情的情况下，红黑树要维护平衡，和链表比起来性能上没什么优势）4.散列函数1234int hash(Object key) &#123; int h = key.hashCode()； return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); //capicity 表示散列表的大小&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表（上）]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、散列表的由来？1.散列表又称Hash Table ,平时也叫它“哈希表”。散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。2.需要存储在散列表中的数据我们称为(key)，将key转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。3.将数据存储在散列值对应的数组下标位置。 二、如何设计散列函数？散列函数的三个基本要求： 1.散列函数计算得到的散列值是一个非负整数。 2.若key1=key2，则hash(key1)=hash(key2) 3.若key≠key2，则hash(key1)≠hash(key2) 对于第三点，在实际场景中因为鸽笼效应（既21只鸽子，20个鸽笼肯定有一个鸽笼有两只鸽子）对应代码问题是数组的大小有限，比如常见的哈希算法取模法。数组的长度是5，这时有一个数据是6。那么如何把这个6存放到长度只有5的数组中呢？按照取模法，计算6％5，结果是1，那么就把6放到数组下标是1的位置。所以在数组大小受限的情况下散列冲突是必然产生的。 三、散列冲突的解放方法？那么既然散列冲突无法避免如何去解决散列冲突呢？常用的散列冲突解决方法有2类：开放寻址法（open addressing）和链表法（chaining） 1.开放寻址法核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。 线性探测法（Linear Probing）：插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到空闲位置，将其插入。查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。删除数据：在查找时如果元素为空则表示不在散列表中，为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。极端情况下需要遍历整个数组所以最坏时间复杂度为O(n) 二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。 双重散列（Double hashing）：不使用一个散列函数而是使用一组散列函数（hash1(),hash2()），先用第一个散列函数，如果得到的存储位置被占用则使用第二个，依次类推，直到找到空闲位置为止。 不管使用什么方法，当散列表空闲位置不多时，散列冲突概率就会很高，为了保证散列表的操作效率，一般情况都会保证散列表有一定比例的空位在此用“装载因子”来表示空位多少。 散列表装载因子=填入表中的个数/散列表的长度。 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 2.链表法（常用）插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。 四、思考1.Word文档中单词拼写检查功能是如何实现的？字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。 2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？遍历 10 万条数据，以 URL 为 key，访问次数为value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果k的数值不大，可使用桶排序，时间复杂度为O(n),如果K的数值较大，就使用快排，时间复杂度为O(NlogN) 3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？先将第一个字符串数组构建一个散列表，key为字符串value为次数。再以第二个字符串数组的值为key遍历，值相同的value+1，最后value大于1的说明有相同字符串。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
