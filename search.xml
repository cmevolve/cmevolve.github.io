<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker-学习二(容器基本操作)]]></title>
    <url>%2F2019%2F11%2F27%2FDocker-%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[内容提要docker容器相关操作，包括容器启停，查看，删除，创建，导入导出，内存配置等。 1.创建并启动容器1.新建容器可以使用docker create命令新建一个容器，例如：1docker create -it ubuntu:latest 2.启动容器使用docker create命令新建的容器处于停止状态需要配合使用docker start 命令启动。1docker start ssf 3.新建并启动容器可以使用docker run 命令来直接新建并启动容器。（如果本地镜像有则启动，没有则获取最新镜像）这里用ubuntu镜像echo一个hello word1docker run ubuntu /bin/echo 'Hello world' 下面的命令启动一个bash终端，允许用户进行交互 并在后台运行：1docker run -it -d ubuntu:14.04 /bin/bash —P参数是随机指定一个32768～61000的主机端口与容器绑定，而－p则是指定一个端口与容器绑定1docker run -d -p 80:80 nginx:v1.0 命令详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-a, --attach=[] Attach to STDIN, STDOUT or STDERR--add-host=[] Add a custom host-to-IP mapping (host:ip)--blkio-weight=0 Block IO (relative weight), between 10 and 1000-c, --cpu-shares=0 CPU shares (relative weight)--cap-add=[] Add Linux capabilities--cap-drop=[] Drop Linux capabilities--cgroup-parent= Optional parent cgroup for the container--cidfile= Write the container ID to the file--cpu-period=0 Limit CPU CFS (Completely Fair Scheduler) period--cpu-quota=0 Limit the CPU CFS quota--cpuset-cpus= CPUs in which to allow execution (0-3, 0,1)--cpuset-mems= MEMs in which to allow execution (0-3, 0,1)-d, --detach=false Run container in background and print container ID--device=[] Add a host device to the container--dns=[] Set custom DNS servers--dns-search=[] Set custom DNS search domains-e, --env=[] Set environment variables--entrypoint= Overwrite the default ENTRYPOINT of the image--env-file=[] Read in a file of environment variables--expose=[] Expose a port or a range of ports-h, --hostname= Container host name--help=false Print usage-i, --interactive=false Keep STDIN open even if not attached--init= Run container following specified init system container method (systemd)--ipc= IPC namespace to use-l, --label=[] Set meta data on a container--label-file=[] Read in a line delimited file of labels--link=[] Add link to another container--log-driver= Logging driver for container--log-opt=[] Log driver options--lxc-conf=[] Add custom lxc options-m, --memory= Memory limit--mac-address= Container MAC address (e.g. 92:d0:c6:0a:29:33)--memory-swap= Total memory (memory + swap), &apos;-1&apos; to disable swap--name= Assign a name to the container--net=bridge Set the Network mode for the container--oom-kill-disable=false Disable OOM Killer-P, --publish-all=false Publish all exposed ports to random ports-p, --publish=[] Publish a container&apos;s port(s) to the host--pid= PID namespace to use--privileged=false Give extended privileges to this container--read-only=false Mount the container&apos;s root filesystem as read only--restart=no Restart policy to apply when a container exits--rm=false Automatically remove the container when it exits--security-opt=[] Security Options--sig-proxy=true Proxy received signals to the process-t, --tty=false Allocate a pseudo-TTY-u, --user= Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])--ulimit=[] Ulimit options--uts= UTS namespace to use-v, --volume=[] Bind mount a volume--volumes-from=[] Mount volumes from the specified container(s)-w, --workdir= Working directory inside the container 2.终止容器1.容器终止可以使用docker stop来终止运行中的容器，格式为：docker stop[-t|–time[=10]][CONTAINER…]首先会向容器发送SIGTERM信号，等待一段超时时间（默认为 10秒）后，再发送 SIGKILL 信号来终止容器。1docker stop ce5 使用 docker kill 命令直接强行终止容器。1docker kill ce5 2.容器重启终止状态的容器可以使用docker start 启动1docker start ce5 在运行状态的容器可以使用docker restart重启1docker restart ce5 3.进入容器进入容器有三种方法，其中主要推荐使用第一种exec方法，其他方法了解作用即可。 1.exec命令(重点)Docker从1.3.0版本起提供了一个更加方便的exec命令，可以在容器内直接执行任意命令。该命令的基本格式为：docker exec [-d|–detach] [–detach-keys[=[]]] [-i|–interactive] [–privileged][-t|–tty] [-u|–user[=USER]] CONTAINER COMMAND [ARG…] 。1docker exec -it 243c32535da7 /bin/bash 通过指定- it 参数来保持标准输入打开，并且分配一个伪终端。 相关参数1234·-i，--interactive=true| false：打开标准输入接受用户输入命令，默认为false；·--privileged=true| false：是否给执行命令以高权限，默认为false；·-t，--tty=true| false：分配伪终端，默认为false；·- u，--user=&quot;&quot;：执行命令的用户名或ID。 2.attach命令命令格式：docker attach [–detach-keys[=[]]] [–no-stdin] [–sig-proxy[=true]] CONTAINER支持三个主要选项：123·--detach-keys[=[]]：指定退出attach 模式的快捷键序列，默认是 CTRL-p CTRL-q；·--no-stdin=true| false：是否关闭标准输入，默认是保持打开；·--sig-proxy=true| false：是否代理收到的系统信号给应用进程，默认为true 使用示例：1docker attach myredis 当多个窗口同时用attach命令连到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时，其他窗口也无法执行操作了。 3.nsenter工具在util-linux 软件包版本2.23+中包含nsenter工具。如果系统中的 util-linux包没有该命令需下载。（略…） 4. 容器操作在容器中操作时，使用ps 报错，是因为ps没有安装在基础wheezy图像。1apt-get update &amp;&amp; apt-get install procps 同样在容器中安装vim等工具时，需要先使用apt-get update 同步一下容器内和服务器的更新源，才可安装。 4.删除容器使用docker rm 命令删除处于终止或者退出状态的容器。命令格式为：docker rm[-f|–force][-l|–link][-v|–volumes]CONTAINER[CONTAINER…]1docker rm ce554267d7a4 默认情况下rm命令只能删除停止或者退出状态的容器，但是可以添加-f参数，将容器kill后强行删除。1docker rm -f ce554267d7a4 ###相关参数123·- f，--force=false：是否强行终止并删除一个运行中的容器；·- l，--link=false：删除容器的连接，但保留容器；·- v，--volumes=false：删除容器挂载的数据卷。 5.导入导出容器1.导出容器命令的格式为 docker export[-o|– output[=””]]CONTAINER123docker export -o test_for_run.tar ce5 或docker export e81 &gt;test_for_stop.tar 2.导入容器和导入镜像一样可以使用docker import将tar导入变成镜像，命令格式为：docker import [-c|–change[=[]]] [-m|–message[=MESSAGE]] file|URL|-[REPOSITORY [:TAG]]导入时可以定义标签信息1docker import test_for_run.tar - test/ubuntu:v1.0 在使用docker load 导入由docker export保存容器生成的tar时会报异常信息：1open /var/lib/docker/tmp/docker-import-283259618/repositories: no such file or directory 导入容器tar需使用docker import命令 6.容器资源配置使用docker stats命令来看当前服务器的内存,针对各个场景对相应容器分配合理内存资源。1docker stats 使用docker的update命令来对内存大小进行管理分配1docker update -m 350m --memory-swap -1 mysqlserver –memory-swap -1 参数是指不让容器和宿主机进行内存交换123--automated=true| false：仅显示自动创建的镜像，默认为否；·--no-trunc=true| false：输出信息不截断显示，默认为否；·- s，--stars=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像。 参考资料：Docker技术入门与实战]]></content>
      <categories>
        <category>Docker容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-学习一（镜像基本操作）]]></title>
    <url>%2F2019%2F11%2F25%2FDocker-%E5%AD%A6%E4%B9%A0%E4%B8%80%EF%BC%88%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内容提要docker镜像相关操作，包括获取，查看，搜索，删除，创建，存出和载入，上传等。 1.启动1servie start docker 为了避免每次使用docker命令都要用特权身份将当前用户加入docker用户组1sudo usermod -aG docker USER_NAME 2.获取镜像可以使用docker pull NAME[：TAG]直接从DockerHub镜像源下载镜像。NAME是镜像仓库名称，TAG是镜像标签（版本信息），例如获取一个Ubuntu14.04系统基本镜像如果不显式指定TAG，则默认会选择latest 标签,这会下载仓库中最新版本的镜像（最新镜像一般非稳定版本）1pulling from library/ubuntu 非官方的仓库下载，则需要在仓库名称前指定完整的仓库地址。例如从网易蜂巢的镜像源来下载ubuntu： 14.04 镜像，可以使用如下命令，此时下载的镜像1docker pull hub.c.163.com/public/ubuntu：14.04 子命令详解1-a，--all-tags=true| false：是否获取仓库中的所有镜像，默认为否。 3.镜像操作1.安装Nginx 并启动pull镜像，并启动 -d后台启动 -p宿主机端口映射容器端口。1sudo docker run -d -p 80:80 --restart=always nginx:latest 此时访问即可80端口即可。 2.images列出镜像1docker images 在列出的信息中，可以看到的信息： 来自于哪个仓库，比如 ubuntu 仓库用来保存 ubuntu 系列的基础镜像； 镜像的标签信息，比如14.04、latest用来标注不同的版本信息。 镜像的ID（唯一标识镜像）如oracle11g与registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g镜像ID相同证明实际上指向的是同一镜像。 创建时间，说明镜像最后的更新时间； 镜像大小 镜像ID信息十分重要，它标识了镜像。在使用时前若干个字符串来代替完整ID.TAG 信息用来标记来自同一个仓库的不同镜像。通过TAG信息来区分发行版本。 子命令详解12345678-a，--all=true| false：列出所有的镜像文件（包括临时文件），默认为否；--digests=true| false：列出镜像的数字摘要值，默认为否-f，--filter=[]：过滤列出的镜像，如 dangling=true 只显示没有被使用的镜像；也可指定带有特定标注的镜像等--format=&quot;TEMPLATE&quot;：控制输出格式，如.ID代表 ID信息，.Repository代表仓库信息等；-no-trunc=true| false：对输出结果中太长的部分是否进行截断，如镜像的ID 信息，默认为是-q，--quiet=true|false：仅输出ID信息，默认为否。更多子命令选项还可以通过 man docker-images 来查看 3.使用tag 命令添加镜像标签为了方便在后续工作中使用特定镜像，还可以使用 docker tag命令来为本地镜像任意添加新的标签。例如添加一个新的oracle镜像标签1docker tag registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g oracle11g:latest 也可以指定镜像ID来修改其标签1docker tag 5sbdf471761 test/oracle11g:latest 4.使用inspect 命令查看详细信息使用docker inspect 命令可以获取该镜像的详细信息，包括制作者、架构、各层的数字摘要等123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112[ &#123; "Id": "sha256:4152a960875253728e0ba43da37d023e4626c43a268ca0a9c6083119542119fb", "RepoTags": [ "nginx:latest" ], "RepoDigests": [ "nginx@sha256:9916837e6b165e967e2beb5a586b1c980084d08eb3b3d7f79178a0c79426d880" ], "Parent": "", "Comment": "", "Created": "2019-11-20T01:15:47.501397881Z", "Container": "b976da4ad5a3f13d191cfedd87ab06bc7b3bf0d5eb37876fa091c3aaae572056", "ContainerConfig": &#123; "Hostname": "b976da4ad5a3", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "ExposedPorts": &#123; "80/tcp": &#123;&#125; &#125;, "Tty": false, "OpenStdin": false, "StdinOnce": false, "Env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "NGINX_VERSION=1.17.6", "NJS_VERSION=0.3.7", "PKG_RELEASE=1~buster" ], "Cmd": [ "/bin/sh", "-c", "#(nop) ", "CMD [\"nginx\" \"-g\" \"daemon off;\"]" ], "ArgsEscaped": true, "Image": "sha256:d96abf34b30211ae8cdb9700ff30dddb3b45ed410bb159fe562ea428b6280851", "Volumes": null, "WorkingDir": "", "Entrypoint": null, "OnBuild": null, "Labels": &#123; "maintainer": "NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;" &#125;, "StopSignal": "SIGTERM" &#125;, "DockerVersion": "18.06.1-ce", "Author": "", "Config": &#123; "Hostname": "", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "ExposedPorts": &#123; "80/tcp": &#123;&#125; &#125;, "Tty": false, "OpenStdin": false, "StdinOnce": false, "Env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "NGINX_VERSION=1.17.6", "NJS_VERSION=0.3.7", "PKG_RELEASE=1~buster" ], "Cmd": [ "nginx", "-g", "daemon off;" ], "ArgsEscaped": true, "Image": "sha256:d96abf34b30211ae8cdb9700ff30dddb3b45ed410bb159fe562ea428b6280851", "Volumes": null, "WorkingDir": "", "Entrypoint": null, "OnBuild": null, "Labels": &#123; "maintainer": "NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;" &#125;, "StopSignal": "SIGTERM" &#125;, "Architecture": "amd64", "Os": "linux", "Size": 126346569, "VirtualSize": 126346569, "GraphDriver": &#123; "Data": &#123; "LowerDir": "/var/lib/docker/overlay2/da7346d91a599e73e4d394bb85a467ac618131460f846683aaa596c779b1ea07/diff:/var/lib/docker/overlay2/5c3cf4f87fe4f7f16433918981eb3471b5bc2b23eea1c0883db2d3561b73dd47/diff", "MergedDir": "/var/lib/docker/overlay2/6168e5e9a57d684f9c5809e6e4722c73bc2434326d39e90cfcdefe0a1b84999d/merged", "UpperDir": "/var/lib/docker/overlay2/6168e5e9a57d684f9c5809e6e4722c73bc2434326d39e90cfcdefe0a1b84999d/diff", "WorkDir": "/var/lib/docker/overlay2/6168e5e9a57d684f9c5809e6e4722c73bc2434326d39e90cfcdefe0a1b84999d/work" &#125;, "Name": "overlay2" &#125;, "RootFS": &#123; "Type": "layers", "Layers": [ "sha256:b67d19e65ef653823ed62a5835399c610a40e8205c16f839c5cc567954fcf594", "sha256:de1b802e9897894b1f7e78346beda84dce9ba1c5514f3d479d40bb553bc623f8", "sha256:c2d3130eb3f6afd3ad600119c363e84f33b0d05837de48adf7b638bc66403397" ] &#125;, "Metadata": &#123; "LastTagTime": "0001-01-01T00:00:00Z" &#125; &#125;] 返回的是一个json格式的信息，如果要获取其中一项内容可使用-f来指定12docker inspect -f &#123;&#123;".Architecture"&#125;&#125;amd64 5.使用history 命令查看镜像历史例如，查看ubuntu： 14.04 镜像的创建过程，可以使用如下命令：1docker history ubuntu:14.04 -- no-trunc 过长的命令会被自动截断，可以使用– no-trunc 选项来输出完整命令。 6.搜寻镜像查找远端仓库镜像，默认搜索官方仓库镜像1docker search --automated -s 10 redis 上述命令：查找自动创建评价为10+带redis关键字的镜像 7.删除镜像1.使用标签删除命令格式为 docker rmi IMAGE[IMAGE…]，其中IMAGE可以为标签或ID例如删除redis：latest镜像1docker rmi redis:latest 当多个标签指向同一镜像文件时，rmi命令只删除该镜像的指定标签。当只有一个镜像标签时使用命令时需注意，此时会删除镜像文件。 2.使用镜像ID删除当使用docker rmi 后面跟上了镜像的ID,此时会先删除所有指向该镜像的标签，然后删除镜像。但是当该镜像创造的容器还存在时，镜像是无法被删除的。如果想强行删除镜像可以使用 -f 参数强制删除一个存在容器依赖的镜像。但是不推荐这么使用1docker rmi -f redis:4.0 正确做法是先找到依赖该镜像的容器依次删除，然后再执行docker rm 命令删除镜像。 8.创建镜像创建镜像的方法主要有三种：基于已有镜像的容器创建、基于本地模板导入、基于 Dockerfile 创建。（Dockerfile 方法后续补充） 1. 基于已有镜像的容器创建在原有镜像中进行改动后提交,其中51a551dea4f7为容器ID.1docker commit -m'Add a new file' -a "lfc" 51a551dea4f7 test:0.1 子命令123456·-a，--author=&quot;&quot;：作者信息；·- c，--change=[]：提交的时候执行 Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR等；·-m，--message=&quot;&quot;：提交消息；·- p，--pause=true：提交时暂停容器运行。 2. 基于本地模板导入使用镜像模版来创建，OPENVZ模板的下载地址为http://openvz.org/Download/templates/precreated。命令格式为1docker import[OPTIONS]file|URL| [REPOSITORY[:TAG]] 例如下载Ubuntu模版压缩包，之后用命令导入1cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04 9.镜像导出和载入1.镜像导出12docker save -o ubuntu_14.04.tar ubuntu:14.04或 docker save nginx &gt;/tmp/nginx.tar.gz 导出本地Ubuntu镜像为文件Ubuntu14，04.tar 2.镜像载入可以使用docker load将导出的tar文件导入到本地镜像库，例如123docker load --input ubuntu_14.04.tar或：docker load &lt; ubuntu_14.04.tar 注：另外 docker load 和 docker import都可以导入一个镜像存储文件， 区别：docker import：丢弃了所有的历史记录和元数据信息，仅保存容器当时的快照状态。在导入的时候可以重新制定标签等元数据信息。docker load：将保存完整记录，体积较大。 10.上传镜像使用docker push 命令上传镜像到仓库，默认上传到docker hub官方仓库。命令格式：1docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG] 例如将test镜像添加新的标签user/test:latest 然后用docker push 上传镜像。12docker tag test:latest user/test:latestdocker push user/test:latest 参考资料：Docker技术入门与实战]]></content>
      <categories>
        <category>Docker镜像</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 安装VNC]]></title>
    <url>%2F2019%2F11%2F21%2FUbuntu-%E5%AE%89%E8%A3%85VNC%2F</url>
    <content type="text"><![CDATA[最近在用Windows 连接 Ubuntu的PC时想使用下图形化界面，因为之前玩树莓派用过VNC因此将为PC安装VNC 来进行图形传输。 准备工作：windows安装VNC-Viewer 或者相关工具，Linux 安装vncserver. 1.安装1.1更新源和系统12apt updateapt upgrade -y 1.2安装桌面mate 桌面较为精简且不会出现显示不全的问题，选择其中一个安装即可。12345678apt install ubuntu-desktop, gnome-panel # Gnome桌面apt install kubuntu-full # KDE桌面# Mate桌面 （推荐）# 仅安装核心组件apt install ntpapt install ubuntu-mate-core# 完整安装apt install ubuntu-mate-core ubuntu-mate-desktop 2.基本操作安装 VNC server1apt install vnc4server -y 第一次启动需要配置密码1vncserver (或vnc4server) 打开会话1vncserver :1 关闭会话1vncserver -kill :1 设置分辨率1vncserver -geometry 1920x1080 :1 3.文件配置vim /root/.vnc添加配置：123456789101112#!/bin/sh # Uncomment the following two lines for normal desktop:# unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrc[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid grey vncconfig -iconic &amp;# x-terminal-emulator -geometry 80x24+10+10 -ls -title "$VNCDESKTOP Desktop" &amp; mate-session &amp; 其他桌面配置：1234gnome-panel &amp;gnome-settings-daemon &amp;metacity &amp;nautilus &amp; #4.开机启动首先输入 crontab 命令,显示如下：123Select an editor. To change later, run ‘select-editor’.1. /bin/ed2. /bin/nano &lt;---- easiest 3. /usr/bin/vim.basic 4. /usr/bin/vim.tiny Choose 1-4 [2]: 在末尾添加命令,设置开机启动1@reboot /usr/bin/vncserver :1 重启服务1reboot]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口的幂等性设计]]></title>
    <url>%2F2019%2F11%2F20%2F%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1.概念 幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现. ——————【维基百科】 简单来说就是 一个操作如果执行多次，其产生的影响均与一次执行的影响相同。 2.为什么要做幂等分布式场景： 一个订单创建接口，在第一次调用时超时。 订单创建时，要先减去库存，调用接口时发生了超时。 订单开始支付，支付请求发出了之后，在到达微信支付前就发生超时。 到达微信支付，但是支付交易失败，未返回，此时超时。 到达微信支付且交易成功，未返回回执，此时超时。 到达微信支付并且交易成功，返回了回执，客户端未接收到回执此时客户端超时。 订单支付成功，调用订单状态更新接口，调用方发送了两条消息，一个是已创建，一个是已付款，如果先收到已付款消息后收到已创建。 幂等性在购物支付场景下显得尤为重要，我请求了多次是否会产生了多笔订单，是否引发了多次支付？为了解决这些问题，就必须保证API的幂等性，也就是接口可重复调用，接口最终结果是与一次调用时一致。（这里说的是数据一致性，不是返回结果一致性，如：已提交订单，再次提交提示请勿重复提交，但是数据结果与第一次调用时一致） 3.幂等如何实现具体方案有：业务去重表（建立唯一索引）、悲观锁、乐观锁（版本控制、有限状态机验证）、Token（全局唯一标识）、分布式锁、select+insert、 3.1 Token(全局唯一标识) 在数据提交前向服务申请token，token放到redis或者内存中（加入失效时间）；在提交时后台校验token，同时删除token，生成新的token返回。（此处校验token和删除token为原子性操作，，如果分为两步，存在并发问题。） 全局唯一标识原理与之类似，根据操作类型和业务标识组合生成一个全局ID，执行操作前判断是否已存在该key，如果不存在则存储到系统中，存在则表示该方法已操作。（利用Redis的setnx命令。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功。） 3.2 唯一索引在CRUD中查询和删除（物理删除、逻辑删除）是天然的幂等的，既多次查询对数据与一次查询一致不会产生影响，删除也是无论是物理删除还是逻辑删除，都是根据条件进行删除无论执行几次造成的结果是一样的。增加数据时如果不进行幂等会导致目标数据产生多条，此时建议将目标表增加唯一索引或者唯一组合索引防止脏数据，在重复进行执行时，插入失败时，重新查询数据此时已存在则成功返回。 3.3 数据库悲观锁获取数据时加锁1select * from table_xxx where id='xxx' for update; 使用时ID需要是主键或者唯一索引，在mysql中会导致锁表而不是行级锁。悲观锁使用一般同事务一起使用。 3.4 数据库乐观锁乐观锁在更新数据时才会产生锁表，其他时间不锁表，所以对比悲观锁，乐观锁并发场景使用效率更高。实现方式：原理如图：同java CAS 通过版本号或者状态条件实现 1update table_xxx set name=#name#,version=version+1 where version=#version# and id=#id#; 通过条件限制 1update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &gt;= 0 and id=#id#; 此场景适用于秒杀等库存场景，防止因并发出现库存-1场景。 任务相关的业务，肯定会涉及到状态机（状态变更），业务数据在不同情况下回发生变更，一般情况下存在有限状态机，如果状态机位于下一个状态，此时来了一个上一个状态的变更，此时不能变更，从而保证有限状态机的幂等。例：订单创建为0，付款成功为2，付款失败为1在进行状态机更新时可以这样控制1update table_xx set status=#status# where id=#id# and status&lt;#status# 如果此次操作成功该update返回结果为1条，若数据已被更新则返回结果为0条，可再次查询验证更新状态是否成功。 3.5 select + insert对并发不高的系统，为了支持幂等可以先查询下数据判断是否已经执行过，未执行则进行业务的处理。注：此种方法高并发场景切不可使用 3.6 业务去重表上面几种通过数据库进行幂等的方法有一个弊端，就是为了实现幂等性需要在业务表中加入一个无关的版本号或者状态，此时可将操作单独提取出来构建一个业务去重表，在业务表操作前对此表进行操作验证，利用数据库唯一索引特性保证唯一逻辑，唯一的序列号可以是一个字段，也可以是多字段的唯一性组合，在幂等验证通过后方可进行业务操作。表结构:123456789101112131415161718192021222324252627282930313233343536create table DUPLICATEREMOVAL( c_id VARCHAR2(32) not null, c_serial_no VARCHAR2(255) not null, c_source_type VARCHAR2(255), c_status VARCHAR2(64), c_remark VARCHAR2(255), c_crt_cde VARCHAR2(20) , t_crt_tm DATE , c_upd_cde VARCHAR2(20), t_upd_tm DATE);-- Add comments to the table comment on table DUPLICATEREMOVAL is '业务去重表';-- Add comments to the columns comment on column DUPLICATEREMOVAL.c_id is '业务标识';comment on column DUPLICATEREMOVAL.c_serial_no is '唯一标识';comment on column DUPLICATEREMOVAL.c_source_type is '资源类型';comment on column DUPLICATEREMOVAL.c_status is '状态';comment on column DUPLICATEREMOVAL.c_remark is '备注';comment on column DUPLICATEREMOVAL.c_crt_cde is '创建人';comment on column DUPLICATEREMOVAL.t_crt_tm is '创建时间';comment on column DUPLICATEREMOVAL.c_upd_cde is '修改人';comment on column DUPLICATEREMOVAL.t_upd_tm is '修改时间';-- Create/Recreate primary, unique and foreign key constraints alter table DUPLICATEREMOVAL add constraint C_PK_SERIAL unique (C_ID, C_SERIAL_NO); 3.7 分布式锁在分布式应用的时代背景下，跨系统的调用想满足锁的语义只能依赖于第三方的中间件，比如redis、zookeeper。实现点：某个流程要求不能并发执行，可以在执行之前根据业务上的唯一标识 获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完后，释放分布式锁。 使用方式：API文档加锁：set key value px milliseconds nx键不存在时才进行操作并设置键的过期时间，此命令是原子操作不会出现多线程问题。释放锁：在释放锁时为了防止将别的线程加的锁误删可以在加锁时将线程id作为value，解锁时判断是否是当前锁，然后删除。但是判断和释放锁是两个独立的操作不具备原子性所以此处推荐使用del+lua脚本实现。https://ftp.bmp.ovh/imgs/2019/11/a79904d25d081716.png12String luaScript = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId)); 分布式锁参考：使用 px nx 加锁扩展：redis官方支持的分布式锁redlock 4.基于redis实现分布式锁4.1 核心加锁代码：12345678910111213141516171819//SET IF NOT EXIST key不存在时，setprivate static final String SET_IF_NOT_EXIST = "NX";//expx 超时时间 单位毫秒 EX 单位 秒private static final String SET_WITH_EXPIRE_TIME = "PX";public boolean tryGetDistributedLock( String lockKey, String requestId , int expireTime) &#123; Jedis jedis = null; try &#123; jedis = getJedis(); String result = jedis.set(lockKey, requestId , SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime); if (LOCK_SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; log.error("set key:&#123;&#125; value:&#123;&#125; error", lockKey, requestId , e); &#125; finally &#123; close(jedis); &#125; return false;&#125; 使用NX PX 来保证插入值时的原子性NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；PX，意思是我们要给这个key加一个过期设置。错误使用：1234567public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; Long result = jedis.setnx(lockKey, requestId); if (result == 1) &#123; // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁 jedis.expire(lockKey, expireTime); &#125;&#125; 上面的代码是将赋值的操作分为两步，先设置值，成功了再设置超时时间，但是如果在未设置超时时间前程序崩溃，此处会形成死锁。 4.2 解锁代码：12345678 public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) &#123; String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) &#123; return true; &#125; return false;&#125; 使用lua脚本将解锁时判断如果获取的key = 目标值则执行后续的操作，保证比较并操作行为的原子性。错误代码：1234567public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) &#123; // 判断加锁与解锁是不是同一个客户端 if (requestId.equals(jedis.get(lockKey))) &#123; // 若在此时，这把锁突然不是这个客户端的，则会误解锁 jedis.del(lockKey); &#125;&#125; 如果经过上面比较判断后，此时锁因为超时已经过期了，在执行后面的del命令时可能会删除别的进程（线程）加的锁。 代码地址：https://github.com/cmevolve/InterfaceIdempotent参考资料：https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/ 5.代码测试（工具扩展）压力测试工具：JMeter性能分析工具：JProfiler 基本使用手册Springboot+redis+注解+拦截器]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志输出使用姿势]]></title>
    <url>%2F2019%2F10%2F10%2F%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[1.什么是日志？日志是记录程序运行的轨迹，方便查找信息，快速定位问题。日志应用主要有下面三个原因：记录操作轨迹、监控系统运行状况、回溯系统故障。在开发时可以使用debug来跟踪代码，真正代码发布到了DAT 生产环境是没办法随便使用远程调试的。因此如果日志打的好，线上的问题很快便能定位，反之用不好则影响系统性能。 2.如何引入日志？常用日志框架及区别在使用日志前先来认识下常用的日志框架：log4j、log4j2、Logging、commons-logging、slf4j、logback等，那么它们之间有什么关系，又该如何选择呢？日志框架分为三大部分：日志门面、日志适配器、日志库。 门面设计模式是面向对象设计模式中的一种，日志框架采用的就是这种模式，类似jdbc的概念，既它只是一套设计规范，并不提供具体的实现。目的使使用者无论使用什么日志框架都无需关心其具体具体是哪个库负责打印。目前主流使用的框架有两种：slf4j、commons-logging。 日志库具体实现了日志的相关功能，主流日志库有：log4j、log4j2、log-jdk、logback。 日志适配器是针对没有实现门面模式接口的日志框架想使用类似于self4j这种门面模式框架时，需要单独引入一个适配器来解决接口不兼容的问题。或者在老的工程中，使用了多种日志框架，随着时间的推移，想将原来直接调用日志库的模式改成门面模式，此时可使用适配器来完成旧API到slf4j的路由。 日志级别详解所以，日志优先级别标准顺序为： ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF 使用方式以springboot中的slf4j+logback为例Spring boot默认支持的就是slf4j+logback的日志框架,想要定制日志策略只需要添加配置文件即可。spring推荐配置文件以-spring命名。此处命名为logback-spring.xml。 基本配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!-- 日志存放路径 --&gt; &lt;property name="log.path" value="./logs" /&gt; &lt;!-- 日志输出格式 --&gt; &lt;property name="log.pattern" value=" %contextName %d&#123;HH:mm:ss.SSS&#125; [logid=%logid] [ip=%ip] [%thread] %-5level %logger&#123;20&#125; - [%method,%line] - %msg%n" /&gt; &lt;conversionRule conversionWord="ip" converterClass="io.renren.IPLogConfig" /&gt; &lt;conversionRule conversionWord="logid" converterClass="io.renren.LogIdConfig" /&gt; &lt;contextName&gt;myLogBack&lt;/contextName&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 系统日志输出 --&gt; &lt;appender name="file_info" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;/sys-info.log&lt;/file&gt; &lt;!-- 循环政策：基于时间创建日志文件 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 日志文件名格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/sys-info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;!-- 过滤的级别 --&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;!-- 匹配时的操作：接收（记录） --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 不匹配时的操作：拒绝（不记录） --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="file_error" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;/sys-error.log&lt;/file&gt; &lt;!-- 循环政策：基于时间创建日志文件 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 日志文件名格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/sys-error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;!-- 过滤的级别 --&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;!-- 匹配时的操作：接收（记录） --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 不匹配时的操作：拒绝（不记录） --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 用户访问日志输出 --&gt; &lt;appender name="sys-user" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;/sys-user.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/sys-user.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- sql 输出配置 --&gt; &lt;appender name="log.dao" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;/log-dao.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/log-dao.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 2天 --&gt; &lt;maxHistory&gt;2&lt;/maxHistory&gt; &lt;!-- 日志最大文件大小10m --&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 系统模块日志级别控制 --&gt; &lt;logger name="io.renren.config" level="info" /&gt; &lt;!-- Spring日志级别控制 --&gt; &lt;logger name="org.springframework" level="warn" /&gt; &lt;!--系统操作日志--&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;/root&gt; &lt;!--系统用户操作日志--&gt; &lt;logger name="sys-user" level="info"&gt; &lt;appender-ref ref="sys-user"/&gt; &lt;/logger&gt; &lt;!--sql日志--&gt; &lt;logger name="io.renren.dao" level="DEBUG"&gt; &lt;appender-ref ref="log.dao"/&gt; &lt;/logger&gt;&lt;/configuration&gt; contextName：设置上下文名称，用来区分不同进程 property 两个属性name 和value,name是变量名称，定义后可使用${}来使用。 appender格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。（控制台输出ConsoleAppender、输出到文件RollingFileAppender）设置文件大小限制和保留天数时冲突解决方案：https://blog.csdn.net/wujianmin577/article/details/68922545 encoder 表示日志编码：%d{HH: mm:ss.SSS}输出时间、%thread——输出日志的进程名字、%-5level——日志级别，并且使用5个字符靠左对齐、%msg——日志消息、%n——平台的换行符 logger 设置某一个包或者具体的某一个类的日志打印级别、以及指定。仅有一个name属性，一个可选的level和一个可选的addtivity属性。addtivity ：是否向上级logger传递打印信息。默认是true conversionRule 可配置自定义class来输出到日志中. 3.使用时需要注意什么？1.日志命名的规范推荐日志的命名方式为：appName_logType_logName.log,logType是日志类型，推荐分类有stats、monitor、visit等；logName为日志描述。这种命名方式的好处是通过文件名就可以知道日志文件属于什么应用，什么类型。 2.日志的存储周期在EasyCoding中推荐将日志文件至少保存15天，防止以周为频率发生的异常无法被发现。然后根据日志文件的重要程度，文件大小，磁盘空间来自行延长保存时间。 3.使用时注意在使用时为了防止产生无用的字符串对象，建议使用条件判断 + 占位符形式来输出日志。例：12345//使用条件判断形式if(myLogger.isInfoEnabled())&#123;//使用占位符形式 myLogger.info("This logInfo id:&#123;&#125;,and value:&#123;&#125;","木大木大木大","阿嘟嘟嘟嘟");&#125; 4.避免无效的日志输出因为日志打印的顺序是由低到高先子级再父级，包名级别越高则logger的级别越高。在执行完子级日志后执行父级日志会重复输出，此时应在子级配置中设置additivity=”false”，例：12&lt;!-- 系统模块日志级别控制 --&gt;&lt;logger name="io.renren.config" level="info" additivity="false"/&gt; 5.使用异步写入日志AsyncAppender一般程序使用串行状态，要记录日志时必然会阻塞到程序的运行，这是一种损耗效率的方式，所以实际使用日志时使用异步的方式来记录，这样日志同主程序就会形成并行状态，不会影响程序运行。 AsyncAppender并不处理日志，只是将日志缓冲到一个BlockingQueue里面去，并在内部创建一个工作线程从队列头部获取日志，之后将获取的日志循环记录到附加的其他appender上去，从而达到不阻塞主线程的效果。因此AsynAppender仅仅充当事件转发器，必须引用另一个appender来写日志。12345678&lt;appender name ="ASYNC" class= "ch.qos.logback.classic.AsyncAppender"&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold &gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;512&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref ="FILE_LOG"/&gt;&lt;/appender&gt; 6.根据环境不同使用不同的日志策略12345678910111213&lt;!-- 开发环境输出到控制台 --&gt;&lt;springProfile name="dev"&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/springProfile&gt;&lt;!-- 生产环境输出到文件 --&gt;&lt;springProfile name="prod"&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="FILE_LOG" /&gt; &lt;/root&gt;&lt;/springProfile&gt; 在root节点外面套了一层springProfile ，指定了name属性的值，此时启用时有两种方式.方式1：执行jar包时添加参数： 1java -jar xxx.jar --spring.profiles.active=prod 方式2：在项目的application.properties配置文件中添加：1spring.profiles.active=prod 4.整合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!--定义一个将日志输出到控制台的appender，名称为STDOUT --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;[%contextName]%date [%thread %line] %level &gt;&gt; %msg &gt;&gt; %logger&#123;10&#125;%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--定义一个将日志输出到文件的appender，名称为FILE_LOG --&gt; &lt;appender name="FILE_LOG" class="ch.qos.logback.core.FileAppender"&gt; &lt;file&gt;D:/test.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;[Eran]%date [%thread %line] %level &gt;&gt; %msg &gt;&gt; %logger&#123;10&#125;%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按时间滚动产生日志文件 --&gt; &lt;appender name="ROL-FILE-LOG" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;D:/logs/test.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 只保留近七天的日志 --&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;!-- 用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志 --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[Eran]%date [%thread %line] %level &gt;&gt; %msg &gt;&gt; %logger&#123;10&#125;%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按时间和文件大小滚动产生日志文件 --&gt; &lt;appender name="ROL-SIZE-FILE-LOG" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;D:/logs/test.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;!-- 单个文件的最大内存 --&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;!-- 只保留近七天的日志 --&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;!-- 用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志 --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[Eran]%date [%thread %line] %level &gt;&gt; %msg &gt;&gt; %logger&#123;10&#125;%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 只处理INFO级别以及之上的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;!-- 只处理INFO级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 异步写入日志 --&gt; &lt;appender name ="ASYNC" class= "ch.qos.logback.classic.AsyncAppender"&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold &gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;512&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref ="FILE_LOG"/&gt; &lt;/appender&gt; &lt;!-- 指定com.demo包下的日志打印级别为DEBUG，但是由于没有引用appender，所以该logger不会打印日志信息，日志信息向上传递 --&gt; &lt;logger name="com.example" level="DEBUG"&gt;&lt;/logger&gt; &lt;!-- 指定开发环境基础的日志输出级别为DEBUG，并且绑定了名为STDOUT的appender，表示将日志信息输出到控制台 --&gt; &lt;springProfile name="dev"&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!-- 指定生产环境基础的日志输出级别为INFO，并且绑定了名为ASYNC的appender，表示将日志信息异步输出到文件 --&gt; &lt;springProfile name="prod"&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="ASYNC" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 参考资源：https://juejin.im/post/5c7e2445f265da2de71370f2http://tengj.top/2017/04/05/springboot7/#%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BAhttps://blog.csdn.net/wujianmin577/article/details/68922545http://tengj.top/2017/02/28/springboot2/]]></content>
      <categories>
        <category>框架</category>
        <category>SpringBoot</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习五-GateWay网关]]></title>
    <url>%2F2019%2F10%2F10%2FSpringCloud%E5%AD%A6%E4%B9%A0%E4%BA%94-GateWay%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1.GateWay是什么？GateWay 是SpringCloud 生态系统中的网关，目标是替代Zuul，同样提供了限流，监控，路由转发、权限校验等功能。 相关名词： Route（路由）：这是网关的基本构建块。它由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配。 Predicate（断言）：这是一个 Java 8 的 Predicate。输入类型是一个 ServerWebExchange。我们可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。 Filter（过滤器）：这是org.springframework.cloud.gateway.filter.GatewayFilter的实例，我们可以使用它修改请求和响应。 工作流程： 客户端向 Spring Cloud Gateway 发出请求，如果HandlerMapping中找到了请求相匹配的路由，将其发送到Web Handler。Handler再通过指定过滤器链将请求发送到实际服务之星业务逻辑，然后返回。虚线是过滤器可能会在发送代理请求之前pre活之后post执行业务逻辑。 2.创建工程2.1依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt; 注意：springcloud gateway使用的web框架为webflux，和springMVC不兼容。 2.2代码12345678910111213@SpringBootApplicationpublic class GateWayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GateWayApplication.class, args); &#125; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; return builder.routes() .route("test_route", r -&gt; r.path("/test") .uri("http://baidu.com")) .build(); &#125;&#125; 路由有两种配置方式，一种是像上面这样配置一个id名为test_route的路由，当访问项目地址/test的时候，会自动转发到baidu.com。另一种是在配置文件中配置，下面介绍。 2.3配置文件123456789101112server: port: 8080spring: cloud: gateway: routes: - id: test_route uri: http://www.baidu.com predicates: - Path=/foo/** filters: - StripPrefix=1 字段含义如下： id: 自定有路由id，唯一 uri: 跳转的目标地址 predicates: 路由条件 filters： 过滤规则 上面配置的意思是配置了一个id为test_route的路由规则，当访问项目地址/foo/hello的时候自动转发到地址baidu.com。如果上面例子中没有加一个StripPrefix=1过滤器，则目标uri为http://localhost:8000/foo/bar，StripPrefix过滤器是去掉一个路径。routes配置和代码配置保留一处即可。 3.路由规则详解 Predicate 来源于 Java 8，是 Java 8 中引入的一个函数，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。网上有一张图总结了 Spring Cloud 内置的几种 Predicate 的实现。 3.1时间匹配12345678spring: cloud: gateway: routes: - id: time_route uri: http://ityouknow.com predicates: - After=2018-01-20T06:06:06+08:00[Asia/Shanghai] Spring 是通过 ZonedDateTime 来对时间进行的对比，ZonedDateTime 是 Java 8中日期时间功能里，用于表示带时区的日期与时间信息的类，ZonedDateTime支持通过时区来设置时间，中国的时区是：Asia/Shanghai。 After Route Predicate是指在这个时间之后的请求都转发到目标地址。上面的示例是指，请求时间在2018年1月20日6点6分6秒之后的所有请求都转发到地址http://ityouknow.com。+08:00是指时间和UTC时间相差八个小时，时间地区为Asia/Shanghai。 3.2 Cookie匹配Cookie Route Predicate 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。12345678spring: cloud: gateway: routes: - id: cookie_route uri: http://ityouknow.com predicates: - Cookie=ityouknow, kee.e 3.3 通过请求路径匹配(常用)12345678spring: cloud: gateway: routes: - id: host_route uri: http://baidu.com predicates: - Path=/foo/&#123;segment&#125; 如果请求路径符合要求，则此路由将匹配，例如：/foo/1 或者 /foo/bar。使用 curl 测试，命令行输入:1curl http://localhost:8080/foo/1 3.4通过请求参数匹配12345678spring: cloud: gateway: routes: - id: query_route uri: http://ityouknow.com predicates: - Query=smile 这样配置，只要请求中包含 smile 属性的参数即可匹配路由。使用 curl 测试，命令行输入:1curl localhost:8080?smile=x&amp;id=2 4.利用过滤器修改接口的返回报文（后置过滤）各个子服务返回的报文各异，需要在网关对返回报文进行包装统一返回格式。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Component@Slf4jpublic class ResponseFilter implements GlobalFilter, Ordered &#123; //白名单 @Value("$&#123;filter.url.white.list.rsp&#125;") private String[] skipAuthUrls ; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; ServerHttpResponse originalResponse = exchange.getResponse(); String url = exchange.getRequest().getURI().getPath(); //跳过不需要验证的路径 if(Arrays.asList(skipAuthUrls).contains(url))&#123; return chain.filter(exchange); &#125; DataBufferFactory bufferFactory = originalResponse.bufferFactory(); ServerHttpResponseDecorator decoratedResponse = new ServerHttpResponseDecorator(originalResponse) &#123; public Mono&lt;Void&gt; writeWith(Publisher&lt;? extends DataBuffer&gt; body) &#123; if (body instanceof Flux) &#123; Flux&lt;? extends DataBuffer&gt; fluxBody = (Flux&lt;? extends DataBuffer&gt;) body; return super.writeWith(fluxBody.map(dataBuffer -&gt; &#123; // probably should reuse buffers byte[] content = new byte[dataBuffer.readableByteCount()]; dataBuffer.read(content); // 释放掉内存 DataBufferUtils.release(dataBuffer); String rs = new String(content, Charset.forName("UTF-8")); //默认失败 CommonResult commonResult = CommonResult.failed(); try &#123; if(StringUtils.isNotBlank(rs))&#123; JsonResult jsonResult= JSONObject.parseObject(rs,JsonResult.class); if(null != jsonResult )&#123; if(0 == jsonResult.getCode())&#123; commonResult = CommonResult.success(jsonResult.getData(),jsonResult.getMessage()); &#125;else&#123; commonResult = CommonResult.failed(jsonResult.getMessage()); &#125; &#125; &#125; &#125;catch (Exception e)&#123; log.error("转换异常，异常报文：&#123;&#125;",rs); log.error(e.getMessage(),e); &#125; byte[] newRs = JSON.toJSONString(commonResult).getBytes(Charset.forName("UTF-8")); originalResponse.getHeaders().setContentLength(newRs.length);//如果不重新设置长度则收不到消息。 return bufferFactory.wrap(newRs); &#125;)); &#125; return super.writeWith(body); &#125; &#125;; return chain.filter(exchange.mutate().response(decoratedResponse).build()); &#125; /** * * 功能描述: 执行优先级 * 此处order需要小于-1，需要先于NettyWriteResponseFilter过滤器执行 * @param: * @return: * @auther: lfc * @date: 2019/8/25 18:56 */ @Override public int getOrder() &#123; return -99; &#125; 需要注意的是order需要小于-1，需要先于NettyWriteResponseFilter过滤器执行。 5.过滤器拦截权限认证(前置过滤)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Component@Slf4jpublic class AuthFilter implements GlobalFilter, Ordered &#123; @Value("$&#123;filter.url.white.list.req&#125;") private String[] skipAuthUrls; private String jwtBlacklistKeyFormat; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; String url = exchange.getRequest().getURI().getPath(); //跳过不需要验证的路径 if(Arrays.asList(skipAuthUrls).contains(url))&#123; return chain.filter(exchange); &#125; //从请求头中取出token String token = exchange.getRequest().getHeaders().getFirst("Authorization"); //未携带token或token在黑名单内 if (token == null || token.isEmpty() || isBlackToken(token)) &#123; if(log.isDebugEnabled() &amp;&amp; isBlackToken(token))&#123; log.debug("**********此token已加入黑名单**********"); &#125; ServerHttpResponse originalResponse = exchange.getResponse(); originalResponse.setStatusCode(HttpStatus.OK); originalResponse.getHeaders().add("Content-Type", "application/json;charset=UTF-8"); byte[] response = JSONObject.toJSONString(CommonResult.unauthorized(null)).getBytes(StandardCharsets.UTF_8); DataBuffer buffer = originalResponse.bufferFactory().wrap(response); return originalResponse.writeWith(Flux.just(buffer)); &#125; //取出token包含的身份 String data = JWTUtil.getData(token, Constant.JWT_TYPE); if(data.isEmpty())&#123; ServerHttpResponse originalResponse = exchange.getResponse(); originalResponse.setStatusCode(HttpStatus.OK); originalResponse.getHeaders().add("Content-Type", "application/json;charset=UTF-8"); byte[] response = JSONObject.toJSONString(CommonResult.forbidden(null)).getBytes(StandardCharsets.UTF_8); DataBuffer buffer = originalResponse.bufferFactory().wrap(response); return originalResponse.writeWith(Flux.just(buffer)); &#125; UserDTO ud = JSONObject.parseObject(data,UserDTO.class); // 1.解析判断是否被修改 2.根据token 获取redis中的数据以此判断是否超时或有效 if(!JWTUtil.verify(token) || StringUtils.isBlank(JedisUtil.getJson(ud.getJti())))&#123; ServerHttpResponse originalResponse = exchange.getResponse(); originalResponse.setStatusCode(HttpStatus.OK); originalResponse.getHeaders().add("Content-Type", "application/json;charset=UTF-8"); byte[] response = JSONObject.toJSONString(CommonResult.tamperToken(null)).getBytes(StandardCharsets.UTF_8); DataBuffer buffer = originalResponse.bufferFactory().wrap(response); return originalResponse.writeWith(Flux.just(buffer)); &#125; //redis 更新过期时间 JedisUtil.setJson(ud.getJti(),token,Constant.EXRP_HOUR); data = JWTUtil.sign(JSONObject.toJSONString(ud)); //将现在的request，添加当前身份 ServerHttpRequest mutableReq = exchange.getRequest().mutate().header("Authorization", data).build(); ServerWebExchange mutableExchange = exchange.mutate().request(mutableReq).build(); return chain.filter(mutableExchange); &#125; @Override public int getOrder() &#123; return -100; &#125; /** * * 功能描述: 判断token是否在黑名单内 * @param token * @return * @auther: lfc * @date: 2019/9/9 0:34 */ private boolean isBlackToken(String token)&#123;// assert token != null;// return stringRedisTemplate.hasKey(String.format(jwtBlacklistKeyFormat, token)); return false; &#125; GateWay中区分前置过滤还是后置过滤取决于动作在chain.filter方法前还是之后，之后回调的是后置，之前调用的是前置。 参考资源：纯洁微笑 方志鹏-深入理解Spring Cloud与微服务构建]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>SpringCloud</category>
        <category>GateWay</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习四-服务消费者]]></title>
    <url>%2F2019%2F10%2F09%2FSpringCloud%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[前面讲了服务的注册和发现，在微服务架构中，业务会被拆分成一个个的微服务，服务与服务又是如何通讯的？SpringCloud中的通信协议是基于HTTP restful的，其中有两种服务调用方式，一种是ribbon+restTemplate,另一种是feign。 ribbonribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。 1.依赖1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.配置123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8763spring: application: name: service-ribbon 3.代码3.1 在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册(如果使用eureka作为注册中心使用EnableEurekaClient，@EnableDiscoveryClient都可以，若使用consul等需使用@EnableDiscoveryClient)12345678@SpringBootApplication@EnableEurekaClient//@EnableDiscoveryClientpublic class ServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run( ServiceRibbonApplication.class, args ); &#125;&#125; 3.2 @Bean向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。12345@Bean@LoadBalancedRestTemplate restTemplate() &#123; return new RestTemplate();&#125; 3.3 在SERVICE-HI服务中提供远程方法1234567@RestControllerpublic class HelloControler &#123; @GetMapping(value = &quot;/hi&quot;) public String hi(@RequestParam String name) &#123; return helloService.hiService( name ); &#125;&#125; 3.4 注入RestTemplate模版，在service中编写逻辑（远程方法调用）调用SERVICE-HI的Controller中hi方法。12345678@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; public String hiService(String name) &#123; return restTemplate.getForObject("http://SERVICE-HI/hi?name="+name,String.class); &#125;&#125; 3.5 在service-ribbon服务中提供hello接口测试远程调用SERVICE-HI服务方法。123456789@RestControllerpublic class HelloControler &#123; @Autowired HelloService helloService; @GetMapping(value = "/hello") public String hello(@RequestParam String name) &#123; return helloService.hiService( name ); &#125;&#125; 如果SERVICE-HI服务，在注册中心上注册了多个实例，则多次调用时会交替调用服务实例，实现负载。 FeignFeign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。Feign默认集成了Ribbon,和Eureka结合默认实现负载效果。 1.依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2.配置文件123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8765spring: application: name: service-feign 3.代码3.1 在程序的启动类ServiceFeignApplication，加上@EnableFeignClients注解开启Feign的功能如果需要将所有feignAPI接口写到maven的一个子工程里，@EnableFeignClients注解需要指明路径@EnableFeignClients（”com.api.feign”）12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125; 3.2 编写一个controller提供hello接口供外部调用123456789@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @RequestMapping(value = "/hello",method = RequestMethod.GET) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 同ribbon，如果服务提供方开启多个实例，会使用负载依次调用其服务。 本文参考文章：方志鹏-深入理解SpringCloud与微服务构建]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>SpringCloud</category>
        <category>Ribbon</category>
        <category>Feign</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习三-zuul网关搭建]]></title>
    <url>%2F2019%2F10%2F08%2FSpringCloud%E5%AD%A6%E4%B9%A0%E4%B8%89-zuul%E7%BD%91%E5%85%B3%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[由于最后技术选型使用的是GateWay，所以zuul只是搭建的基本功能。 基本配置1.依赖12345678910111213141516171819202122232425&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Dalston.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.配置文件12345678910111213server: port: 8762spring: application: name: zuul-server client: service-url: defaultZone: http://localhost:8761/eureka/zuul: routes: api-a: path: /api-a/** serviceId: law-server 3.启动类12345678@EnableZuulProxy@EnableEurekaClient@SpringBootApplicationpublic class ServiceZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceZuulApplication.class, args); &#125;&#125; 4.测试启动两个服务law-server端口分别是8888 和9999访问 http://localhost:8762/api-a/hi?name=zuul 两次，服务端返回数据如下：12Hi zuul, I am from port: 8888Hi zuul, I am from port: 9999 这说明Zuul 起到了 路由 的作用。如果某个 服务 存在 多个实例，Zuul 会结合 Ribbon 做 负载均衡，将请求 均分并路由 到不同的 服务实例。更多zuul相关配置参考文章：Spring Cloud实战系列(五) - 服务网关Zuulhttp://www.ityouknow.com/springcloud/2017/06/01/gateway-service-zuul.html]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>SpringCloud</category>
        <category>Zuul</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习二-网关技术选型]]></title>
    <url>%2F2019%2F10%2F07%2FSpringCloud%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E7%BD%91%E5%85%B3%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是网关？Eureka用于服务的注册和发现，在发现服务后外部的客户端请求如何访问到服务呢？在微服务中，后端服务一般不会直接对外开放，而是通过一个API网关根据请求的url路由到对应的服务中去。就像家里的路由器一样在服务和客户端之间作为中转，来保护内部的服务，也可以将请求进行负载均衡。 网关的基本功能如下： 技术选型网关相当于微服务世界的大门，可以说是微服务中的核心组件，那么网关的选择又有哪些呢？ Gateway VS ZuulSpring Cloud Gateway 是 Spring Cloud 微服务平台的一个子项目，属于 Spring 开源社区，依赖名叫：spring-cloud-starter-gateway。https://spring.io/projects/spring-cloud-gateway Zuul 是 Netflix 公司的开源项目，Spring Cloud 在 Netflix 项目中也已经集成了 Zuul，依赖名叫：spring-cloud-starter-netflix-zuul。https://link.zhihu.com/?target=https%3A//github.com/Netflix/zuul 功能点：身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求审查与监控：在边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。动态路由：动态将请求路由到不同后端集群压力测试：逐渐增加指向集群的流量，以了解性能负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求静态响应处理：边缘位置进行响应，避免转发到内部集群多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化 对比：Zuul构建于 Servlet 2.5，兼容 3.x，使用的是阻塞式的 API，不支持长连接，比如 websockets。（替代方案：Zuul 支持websockets方案） Spring Cloud Gateway构建于 Spring 5+，基于 Spring Boot 2.x 响应式的、非阻塞式的 API。同时，它支持 websockets，和 Spring 框架紧密集成，开发体验相对来说十分不错。（在后续开发中发现因其基于webflux 整合shiro时与Servlet整合方式不一致，此处需注意） 如何选择？Netflix 早就发布了最新的 Zuul 2.x，但 Spring Cloud一直没有整合计划，在此场景下spring推出了自己的服务网关Spring Cloud Gateway，作为亲儿子在后续版本的更新上比较zuul应该是更有优势的。 网关过滤器过滤器可以说是网关的核心组件了，其中过滤器主要的过滤类型有如下几种。 Zuul过滤器配置123456789filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：pre：路由之前routing：路由之时post： 路由之后error：发送错误调用filterOrder：过滤的顺序shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。原文链接：https://blog.csdn.net/forezp/article/details/81041012 GateWay过滤器配置1234GateWay的过滤器类型没有Zuul丰富，只有pre 和 post 两种tilter方式.客户端的请求先经过“pre”类型的filter,然后将请求转发到具体的业务服务,收到业务服务响应后，在经过“post” 类型filter处理，返回给客户端。与Zuul不同的地方是，GateWay的filter除了单个路由的filter外还有针对所有路由的global GateWay filter。]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>SpringCloud</category>
        <category>Zuul</category>
        <category>GateWay</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习一-服务注册和发现]]></title>
    <url>%2F2019%2F10%2F05%2FSpringCloud%E5%AD%A6%E4%B9%A0%E4%B8%80-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[注册中心-Eureka参考资料史上最简单的 SpringCloud 教程 | 第一篇： 服务的注册与发现Eureka(Finchley版本) Eureka 自我保护机制：某时刻微服务不可用，Eureka不会立刻清理，依旧保存该微服务的信息。 在spring cloud中，除了可以使用eureka作为注册中心外，还可以通过配置的方式使用zookeeper作为注册中心。既然这样，该如何选择？ 著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。 Zookeeper保证CP 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。 Eureka保证AP Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其它节点中因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。配置1.pom文件引入依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 2. 启动类1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run( EurekaServerApplication.class, args ); &#125;&#125; 3.配置文件12345678910111213141516server: port: 8761 #端口eureka: instance: hostname: localhost client: registerWithEureka: false # 禁止自己注册 fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #服务地址spring: application: name: eurka-server # 服务名称 instance: instance-id: eurekaclient8762 #显示别名 prefer-ip-address: true #访问路径显示ip地址]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>SpringCloud</category>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud 学习笔记(资源整合)]]></title>
    <url>%2F2019%2F10%2F03%2FSpringCloud-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[一、微服务单体架构：——优点：1231、易于开发：开发的方式简单，方便运行也容易调试。2、易于测试。3、易于部署。 ——缺点：12345671、项目过于臃肿，维护成本大，出现bug难定位。2、资源无法隔离：共享一个数据库，或者一块内存。如果一个功能模块突然访问量过大，可能影响整个系统的性能。3、无法灵活扩展：单体系统也可以集群部署，但是不够灵活，我明明只是订单系统遇到了瓶颈，只需要将订单模块水平扩展就行，但现在要将整个系统水平扩展。不灵活！4、交付周期长：所有功能得一起上线，一起构建，一起部署。任何一个环节出错，都可能影响交付。 分布式的优点与单体应用缺点对立，但是也带来了一些问题12341.性能，访问速度受带宽影响。2.可靠性，高度依赖网络。3.数据一致性：C（一致性）A（可用性）P（分区容错），cap原理4.运维成本：一个系统拆成了多个服务，每个服务都得配置，部署，监控，日志处理 CAP 定理:http://www.ruanyifeng.com/blog/2018/07/cap.html 微服务就是在分布式的特点上对业务的的一个横向划分，拆分成不同模块对外提供服务。 二.Spring Cloud是什么?Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud就像一个老大哥带了一帮小弟，是一个资源的整合。 三.微服务入门服务链路过程图： 技术选择 1.注册中心参考文章链接：https://blog.csdn.net/forezp/article/details/81040925整理内容连接：https://www.iamlfc.top/2019/08/25/SpringCloud%E5%AD%A6%E4%B9%A0%E4%B8%80-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/ 2.服务消费参考链接：https://blog.csdn.net/forezp/article/details/81040965 3.路由网关zuul: – 参考连接：https://blog.csdn.net/forezp/article/details/81041012gateway: – 参考连接：https://blog.csdn.net/forezp/article/details/85210153 4.配置中心SpringColud Config： – 参考链接：https://www.cnblogs.com/lfalex0831/p/9206605.html 推荐学习资料http://xujin.org/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/http://www.itmuch.com/categories/Spring-Cloud/http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/ demo地址：https://github.com/cmevolve/xieexiaodaima/tree/master/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/springAll/springcloud/springCloud用途 | 技术—-|——基础容器 | spring-boot 2.0.6分布式服务框架 | Spring cloud F SR3项目构建 | Maven注册中心 | eureka网关 |gateway服务消费者|Fegin配置中心 | Spring Cloud Config…]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同一机器配置多个git账号的ssh秘钥]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%90%8C%E4%B8%80%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E5%8F%B7%E7%9A%84ssh%E7%A7%98%E9%92%A5%2F</url>
    <content type="text"><![CDATA[背景个人电脑因工作需要需连接公司gitlab，但是生成的ssh已经连接了GitHub，并且工作的邮箱和个人邮箱也不是一致的，此时需要对不同的平台进行不同的配置。 1.生成ssh key打开git bash 输入以下命令1ssh-keygen -t rsa -C &quot;github-user1@163.com&quot; 第一个 ssh key 使用默认名字，三下回车，完成第一个默认的 ssh key。在当前用户目录的 .ssh 目录下会生成 id_rsa 私钥文件和 id_rsa.pub 公钥文件，将 id_rsa.pub 公钥中的内容添加至 GitHub 云端中。然后在 git bash 中输入以下命令测试该用户的 SSH 密钥是否有效：1ssh -T git@github.com 注明：该命令仅限于文件名为默认 id_rsa 的密钥 2.生成第二个ssh keygit bash 中输入以下命令，生成 gitlab的密钥，此时第二个 SSH Key 不能再使用默认的文件名id_rsa，否则会覆盖之前的密钥文件：1ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitlab -C &quot;gitlab@qq.com&quot; 同样将生成的id_rsa_gitlab.pub内容添加至gitlab云端中。测试1ssh -T git@gitlab.com -i ~/.ssh/id_rsa_gitlab 3.配置config文件 .ssh 目录下创建一个 config 文本文件，每个账号配置一个Host节点，主要配置项说明 Host # 主机别名 HostName # 服务器真实地址 IdentityFile # 私钥文件路径 PreferredAuthentications # 认证方式 User # 用户名 config 文件内容：123456789101112# ~/.ssh/config 配置多个git的ssh-key# 第一个默认的SSH KeyHost github.com HostName github.com IdentityFile C:\\Users\\xx\\.ssh\\id_rsa PreferredAuthentications publickey# 第二个SSH KeyHost gitlab.com HostName gitlab.com IdentityFile C:\\Users\\xx\\.ssh\\id_rsa_gitlab PreferredAuthentications publickey 4.为各自仓库配置不同的用户名和邮箱1git config --local user.name &apos;xx&apos; &amp;&amp; git config --local user.email &apos;xx@qq.com&apos;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习一]]></title>
    <url>%2F2019%2F08%2F18%2FSpringMVC%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、是什么？MVC是一种设计思想既模型（Model）、视图（View）和控制器（Controller）使用这种分层的形式对其进行职能的划分。而springMVC就是使用这种设计理念来快捷开发的web端框架。 二、技术对比说到Java的web开发就不得不提Struts2(没办法谁让我一开始学的就是这个)，Struts2也是控制层的框架那么springMVC与它的差别在哪呢？ 1.首先Struts2 是基于Filter实现而SpringMVC则采用Servlet实现。（Servlet与Filter的区别是servlet不具备传递性，其处理后直接响应，而Filter属于流式处理，它可以在调用filter,servlet的前后进行处理，属于函数回调。函数回调在另一篇笔记中记载） 2.Struts2是类级别的拦截，一个类对应一个request上下文，而SpringMVC是方法级别的拦截，一个方法对应一个request上下文，一个方法跟一个url对应。从这点上考虑，SpringMVC更适合restful编程风格的请求. 3.Struts2 有interceptor拦截器，而SpringMVC则使用的AOP。（拦截器过滤器执行顺序：过滤前-拦截前-action执行-拦截后-过滤后） 三、原理实现1.Struts2原理图(网络图) 2.mvc原理图(网络图) 四、入门实践1.准备jar包依赖1234567891011121314151617181920212223&lt;!--mvc相关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 全家桶必带 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 注解相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 2.配置1.核心控制器-DispatcherServlet在web.xml下配置123456789101112131415&lt;!--配置前端控制器--&gt;&lt;servlet&gt;&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;!-- 启动服务时加载 大于0启动时加载 1,2,3,4,5...标识优先级 --&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; SpringMVC 的配置文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 包扫描 --&gt; &lt;context:component-scan base-package="com.lfc"/&gt; &lt;!-- 视图解析器对象 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 开启SpringMVC框架注解的支持 --&gt; &lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;/beans&gt; 3.程序编写1234567891011@Controller@RequestMapping("/user")public class controller &#123; @RequestMapping(path = "/hello" ) public String sayHello(String name)&#123; System.out.println("Hello SpringMVC"); return "success"; &#125;&#125;//测试页面代码 &lt;a href="user/hello"&gt;入门程序&lt;/a&gt; 4.相关注解1.@RequestMapping可加类上和方法上，在类上时其url为一级目录，方法上时其url为二级目录。属性：value：用于指定请求的 URL。它和 path 属性的作用是一样的。method：用于指定请求的方式。params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value必须和配置的一模一样。params = {“name”}，表示请求参数必须有 name示例：下面这段代码的访问路径是user/hello请求方式必须为指定的post请求，表单请求的参数名必须为name.123456789@Controller@RequestMapping("/user")public class controller &#123; @RequestMapping(path = "/hello" ,method=RequestMethod.POST,params= &#123;"name"&#125;) public String sayHello(String name)&#123; System.out.println("Hello SpringMVC"); return "success"; &#125;&#125; 2.@RequestBody作用：用于获取请求体的内容（get方法不可用！！！）属性：required：是否必须有请求体，默认值是true1234@RequestMapping(path="/hello")public String sayHello(@RequestBody String body) &#123;return "success";&#125; 3.@RequestParam作用：把请求中指定名称的参数传递给控制器并重新赋值。(没有此注解前端传入参数需与方法入参保持一致)属性：value：请求参数中的名称required：请求参数中是否必须提供此参数，默认值是true1234public String sayHello(@RequestParam(value="username",required=false)String name) &#123;System.out.println(name);return "success";&#125; 4.@PathVariable作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符，RestFUl风格url，可请求路径一样，根据不同的请求执行后跳不同的方法1234567&lt;a href="user/hello/1"&gt;入门案例&lt;/a&gt;@RequestMapping(path="/hello/&#123;id&#125;")public String sayHello(@PathVariable(value="id") String id) &#123;System.out.println(id);return "success";&#125; 5.@RequestHeader作用：获取指定请求头的值属性：value 请求头的名称。12345@RequestMapping(path="/hello")public String sayHello(@RequestHeader(value="Accept") String header) &#123;System.out.println(header);return "success";&#125; 6.@CookieValue作用：用于获取指定cookie的名称的值属性: value：cookie的名称12345@RequestMapping(path="/hello")public String sayHello(@CookieValue(value="JSESSIONID") String cookieValue) &#123;System.out.println(cookieValue);return "success";&#125; 7.ModelAttribute注解作用 出现在方法上：表示当前方法会在控制器方法执行前线执行。 出现在参数上：获取指定的数据给参数赋值。12345678910@ModelAttributepublic void testModelAttributes(Map&lt;String, String&gt; map)&#123; map.put("abc", "ModelAttributes"); System.out.println("ModelAttributes 执行了***************");&#125;@RequestMapping("/testModelAttributes")public String testModelAttributes1(@ModelAttribute(name = "abc") String val)&#123; System.out.println("map值为："+val); return "success";&#125; 8.SessionAttributes注解作用：用于多次执行控制器方法间的参数共享属性:value：指定存入属性的名称1234567891011121314151617181920212223242526272829303132333435363738@Controller@RequestMapping(path="/user")@SessionAttributes(value= &#123;"username","password","age"&#125;,types=&#123;String.class,Integer.class&#125;) // 把数据存入到session域对象中public class HelloController &#123;/*** 向session中存入值* @return*/@RequestMapping(path="/save")public String save(Model model) &#123;System.out.println("向session域中保存数据");model.addAttribute("username", "root");model.addAttribute("password", "123");model.addAttribute("age", 20);return "success";&#125;/*** 从session中获取值* @return*/@RequestMapping(path="/find")public String find(ModelMap modelMap) &#123;String username = (String) modelMap.get("username");String password = (String) modelMap.get("password");Integer age = (Integer) modelMap.get("age");System.out.println(username + " : "+password +" : "+age);return "success";&#125;/*** 清除值* @return*/@RequestMapping(path="/delete")public String delete(SessionStatus status) &#123;status.setComplete();return "success";&#125; 8.@InitBinder 注解作用：@InitBinder 标识的方法,可以对 WebDataBinder 对象进行初始化。WebDataBinder 是 DataBinder 的子类,用于完成由表单字段到 JavaBean 属性的绑定。• @InitBinder方法不能有返回值,它必须声明为void。• @InitBinder方法的参数通常是是 WebDataBinder。使用场景：对提交表单的数据进行转换绑定，如前台时间String转换为Date. 1234@InitBinder public void initBinder(WebDataBinder b) &#123; b.registerCustomEditor(Date.class, new ToolUtil()); &#125; 9.@ControllerAdvice注解作用：@ControllerAdvice是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。@ControllerAdvice需要和@ExceptionHandler、@InitBinder以及@ModelAttribute注解搭配使用，主要是用来处理控制器所抛出的异常信息。首先，我们需要定义一个被@ControllerAdvice所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。1234567891011121314151617181920212223242526272829/** * 1、通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。 * 2、注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。 * 3、@ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上。 * 4、@ExceptionHandler：用于全局处理控制器里的异常。 * 5、@InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中。 * 6、@ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对 */@ControllerAdvice public class GlobalControllerInterceptor &#123; @ModelAttribute //应用到所有@RequestMapping注解方法 //此处将键值对添加到全局，注解了@RequestMapping的方法都可以获得此键值对 public void addUser(Model model) &#123; model.addAttribute("msg", "此处将键值对添加到全局，注解了@RequestMapping的方法都可以获得此键值对"); &#125; @InitBinder //应用到所有@RequestMapping注解方法，在其执行之前初始化数据绑定器 //用来设置WebDataBinder，用于自动绑定前台请求参数到Model中。 public void initBinder(WebDataBinder binder) &#123; &#125; @ExceptionHandler(Exception.class) //应用到所有@RequestMapping注解的方法，在其抛出Exception异常时执行 //定义全局异常处理，value属性可以过滤拦截条件，此处拦截所有的Exception public String processUnauthenticatedException(NativeWebRequest request, Exception e) &#123; return "error"; //返回一个逻辑视图名 &#125; &#125; 10.@ResponseBody作用：该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端如果在被@RestController标记的类中，则方法不需要使用@ResponseBody注解进行标注。@RestController相当于是@Controller和@ResponseBody的组合注解。12345@RequestMapping("/testResponseJson")public @ResponseBody Account testResponseJson(@RequestBody Account account) &#123;System.out.println("异步请求："+account);return account;&#125; 11.@ExceptionHandler作用：用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被@ExceptionHandler标注的方法。下面是使用该注解的一个示例：12345@ExceptionHandler(MyException.class) @ResponseBody public String handleException()&#123; return "handle by ExceptionHandler."; &#125; 12.@ResponseStatus作用：可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值12345@ResponseStatus(value = HttpStatus.NOT_FOUND)public class MyException extends RuntimeException&#123;&#125; 5.请求参数乱码问题1.post 请求方式在 web.xml 中配置一个过滤器1234567891011121314151617181920212223&lt;/filter-class&gt; &lt;!-- 设置过滤器中的属性值 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 过滤所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 在 springmvc 的配置文件中可以配置，静态资源不过滤：&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt;&lt;mvc:resources location="/images/" mapping="/images/**"/&gt;&lt;mvc:resources location="/scripts/" mapping="/javascript/**"/&gt; 2.get 请求方式：tomacat 对 GET和 POST 请求处理方式是不同的，GET请求的编码问题，要改 tomcat 的 server.xml配置文件123456&lt;Connector connectionTimeout="20000" port="8080"protocol="HTTP/1.1" redirectPort="8443"/&gt;改为：&lt;Connector connectionTimeout="20000" port="8080"protocol="HTTP/1.1" redirectPort="8443"useBodyEncodingForURI="true"/&gt; 如果 ajax 请求仍然乱码把：useBodyEncodingForURI=”true”改为 URIEncoding=”UTF-8” 6.类型转换前端传递过来的时间是String类型的，Controller 在接收时只能接收String类型的，如果使用入参Date则会导致类型转换异常，此时需对其进行处理。 根据日期删除账户12345@RequestMapping("/deleteAccount")public String deleteAccount(String date) &#123;System.out.println("删除了账户。。。。"+date);return "success";&#125; 方法1：第一步：定义一个类，实现 Converter接口，该接口有两个泛型。1234567891011121314151617181920212223242526272829public interface Converter&lt;S, T&gt; &#123;//S:表示接受的类型，T：表示目标类型/*** 实现类型转换的方法*/@NullableT convert(S source);&#125;/*** 自定义类型转换器*/public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;/*** 用于把 String 类型转成日期类型*/@Overridepublic Date convert(String source) &#123; DateFormat format = null; try &#123; if(StringUtils.isEmpty(source)) &#123; throw new NullPointerException("请输入要转换的日期"); &#125; format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(source); return date; &#125; catch (Exception e) &#123; throw new RuntimeException("输入日期有误"); &#125; &#125;&#125; 第二步：在 spring 配置文件中配置类型转换器。spring 配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。1234567891011&lt;!-- 配置类型转换器工厂 --&gt;&lt;bean id="converterService"class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;&lt;!-- 给工厂注入一个新的类型转换器 --&gt;&lt;property name="converters"&gt;&lt;array&gt;&lt;!-- 配置自定义类型转换器 --&gt;&lt;bean class="com.itheima.web.converter.StringToDateConverter"&gt;&lt;/bean&gt;&lt;/array&gt;&lt;/property&gt;&lt;/bean&gt; 第三步：在 annotation-driven标签中引用配置的类型转换服务123&lt;!-- 引用自定义类型转换器 --&gt;&lt;mvc:annotation-drivenconversion-service="converterService"&gt;&lt;/mvc:annotation-driven&gt; 方法2：写一个DATE数据绑定类，然后在Controller 里面写 InitBinder 方法里面应用1234567891011121314151617181920212223242526272829303132import org.apache.commons.lang.StringUtils;import java.beans.PropertyEditorSupport;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * 时间转换类 */public class ToolUtil extends PropertyEditorSupport &#123; public void setAsText(String text) throws IllegalArgumentException &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = null; try &#123; //防止空数据出错 if(StringUtils.isNotBlank(text))&#123; date = format.parse(text); &#125; &#125; catch (ParseException e) &#123; format = new SimpleDateFormat("yyyy-MM-dd"); try &#123; date = format.parse(text); &#125; catch (ParseException e1) &#123; format = new SimpleDateFormat("yyyy-MM"); try&#123; date = format.parse(text); &#125;catch (Exception e2) &#123; &#125; &#125; &#125; setValue(date); &#125;&#125; 然后在initBinder 方法里直接引用@InitBinder用于在@Controller中标注于方法，表示为当前控制器注册一个属性编辑器或者其他，只对当前的Controller有效。1234@InitBinder public void initBinder(WebDataBinder b) &#123; b.registerCustomEditor(Date.class, new ToolUtil()); &#125;]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-事务管理]]></title>
    <url>%2F2019%2F08%2F05%2FSpring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是事务Spring事务控制的目的是为了达到控制一组操作，要么都执行要么都不执行的一种操作。ACID四大特性: 原子性 ：最小执行单位，不可分割，要么都完成要么无效。 一致性 ：保证数据库数据整体完整性，事务成功则整体数据修改，事务失败则数据回滚到之前的状态。 隔离性 ：各事务之间是独立的，多个事务操作同一对象时，会串行等待方式执行，保证事务之间互不干扰。 持久性 ：事务提交后数据会保存到数据库，之后的数据基于此次保存的数据为基础。 Spring事务控制的API1.PlatformTransactionManager此接口是Spring的事务管理器。它提供了常用操作事务的方法。123456//获取事务状态信息TransactionStatus getTransaction(TransactionDefinition definition)//提交事务Void commit(TransactionStatus status) throws TransactionException; //回滚事务Void rollback(TransactionStatus status) throws TransactionException; 现实开发中使用的是它的实现类进行数据操作，具体有： org.springframework.jdbc.datasource.DataSourceTransactionManager 使用SpringJDBC 或者iBatis进行持久化数据时使用。 org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate进行持久化数据时使用。 org.springframework.orm.jpa.JpaTransactionManager 使用JPA进行持久化数据时使用。 org.springframework.transaction.jta.JtaTransactionManager 使用一个JTA来实现分布式事务管理，在一个事务跨越多个资源时使用。 2.TransactionDefinition事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，这个方法里面的参数是 TransactionDefinition类，这个类就定义了一些基本的事务属性。 方法如下：123456789101112public interface TransactionDefinition &#123;// 返回事务的传播行为int getPropagationBehavior(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据int getIsolationLevel(); // 返回事务超时时间int getTimeout();//返回事务的名字String getName()；// 返回是否为只读事务。 boolean isReadOnly();&#125; 1.并发事务影响事务的隔离级别反映并发操作时受其他事务影响的程度，其中可能带来的问题有： 脏读 ：又叫做读未提交，指的是当前事务对一数据进行了修改，但是并没有提交到数据库中，此时另一事务此时也访问了这个数据，并且使用了数据，而这时当前事务因为异常进行了数据回滚，此时另一事务读到的数据就是”脏数据”，根据脏数据是没法进行正确的操作的。 不可重复读 ：在一个事务内，多次读取同一数据，而两次读取数据中间由另一事务对当前数据进行了修改，导致两次读取数据的值不一样。 幻读 ： 与不可重复读类似，指的是，在一个事务内读取了若干行数据，接着另一事务插入了一些数据，并提交。在当前事务再次进行查询时会发现出现了一些本不存在的数据，就像幻觉一样。 值丢失 ： 在当前事务修改某一数据时，另一事务并发修改同一数据，导致晚提交的事务覆盖了上一提交的事务，造成值丢失。（例如 A=10，事务1更新A=A+20,事务2更新A=A-10,最后导致A=0的与预期值A=20不符） 幻读 和 不可重复读的区别：幻读重点在于新增和删除，而不可重复读的重点在于查询+修改。不可重复读 和 脏读的区别：脏读是当前事务读取了另一事务未提交的数据，而不可重复读是多次查询返回不同的数据值，因为当前数据被另一事务并发更改，并提交。 2.事务隔离级别数据库中定义了4种隔离级别,分别是： read uncommitted 读未提交 所有事务可以看到未提交事务数据。 read committed 读提交 只有事务提交后才可以被其他数据查询到。 Oracle 默认级别 repeatable read 可重复读 (会产生幻读) Mysql默认级别 Serializable 序列化 最高级别，强制事务按照顺序执行，在读的数据行上加上共享锁，可能产生大量的超时现象和锁竞争 TransactionDefinition接口定义了5个隔离等级的常量： ISOLATION_DEFAULT ： 默认 使用数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED ： 读未提交（可能会导致可能会导致脏读、幻读或不可重复读） ISOLATION_READ_COMMITTED 读已提交 （可避免脏读，不可避免幻读和不可重复读） ISOLATION_REPEATABLE_READ ：可重复读，同一字段多次读取结果一致，除非数据被本身事务进行修改（不可避免不可重复读） ISOLATION_SERIALIZABLE: 最高隔离界别 序列化操作（影响性能，慎用！） 3.事务传播事务方法被另一事务调用时，必须指定事务应该如何传播。事务的嵌套，内层事务既可以开启新的事务，也可以将当前事务合并到外层事务中来。具体有：支持当前事务型 PROPAGATION_REQUIRED：如果当前没有事务就新建事务，如果已有事务则加入该事务。 PROPAGATION_SUPPORTS：如果当前没有事务就加入该事务，如果没有事务，则以没有事务方式运行。 PROPAGATION_MANDATORY：如果当前存在事务加入该事务，如果没有事务则抛出异常。 不支持当前事务型 PROPAGATION_REQUIRES_NEW：创建一个新事物，如果当前存在事务，则挂起当前事务。 PROPAGATION_NOT_SUPPORTED：以没有事务方式运行，如果有事务则将当前事务挂起。 PROPAGATION_NEVER： 以非事务方式运行，如果存在事务则抛出异常。 其他 PROPAGATION_NESTED：当前存在事务，则创建事务作为当前事务的嵌套事务，如果没有则取值等价 PROPAGATION_REQUIRED。 PROPAGATION_NESTED 是Spring独有的，其启动的事务如果外部有事务的话内嵌于外部事务，此时内嵌事务不属于独立事务，它依赖外部事物，只有外部事物提交才能引起内部事务提交，内嵌子事务不得独立提交。当然外部事务回滚也会导致内部事务回滚。 4.超时时间超时时间指事务允许执行的最大时间，如果超过限制时间事务还没有完成，则自动回滚事务。默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 5.只读属性事务只读属性指当前事务对事务访问资源进行只读操作还是读写操作。只读操作可提高事务处理性能，可在适当的地方使用。 6.回滚默认情况下事务在运行期异常时会回滚，在检查型异常并不会回滚，但是可以声明事务遇到特定异常时回滚或不回滚，即使该异常是检查型异常。 3.TransactionStatusTransactionStatus 接口用来记录事务的状态，该接口定义了一组方法可以获得某个时间点上事务对象的状态信息。PlatformTransactionManager.getTransaction（）方法返回一个TransactionStatus对象，可能是一个新的事务或者已经存在的事务。接口方法如下： boolean isNewTransaction（） 是否新事务 boolean hasSavepoint（） 是否有恢复点 void flush（） 刷新事务 boolean isRollbackOnly() 是否回滚 void setRollbackOnly() 设置为只回滚 boolean isCompleted（）是否已完成* 配置方式XML配置方式1.准备工作jar包依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件约束配置导入aop和tx两个命名空间123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; 配置数据源12345678&lt;context:property-placeholder location="db.properties"/&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbcUser&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 2.事务配置步骤2.1 配置事务管理器123456&lt;!-- 配置一个事务管理器 --&gt;&lt;bean id="transactionManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;!-- 注入 DataSource --&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2 配置事务通知引用事务管理器123&lt;!-- 事务的配置 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;/tx:advice&gt; 2.3 配置事务属性1234567891011121314&lt;tx:attributes&gt;&lt;!-- 指定方法名称：是业务核心方法read-only：是否是只读事务。默认 false，不只读。isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。propagation：指定事务的传播行为。timeout：指定超时时间。默认值为：-1。永不超时。rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。--&gt;&lt;tx:method name="*" read-only="false" propagation="REQUIRED"/&gt;&lt;!-- REQUIRED 有事务就加入，没有则新建 --&gt;&lt;tx:method name="find*" read-only="true" propagation="SUPPORTS"/&gt; &lt;!-- 在这里对find开头的查询方法使用只读事务 ；SUPPORTS 当前有事务，则加入，没有则无事务--&gt;&lt;/tx:attributes&gt; 2.4 配置切入点表达式12345&lt;!-- 配置 aop --&gt;&lt;aop:config&gt;&lt;!-- 配置切入点表达式 --&gt;&lt;aop:pointcut expression="execution(* com.lfc.service.impl.*.*(..))" id="pt1"/&gt;&lt;/aop:config&gt; 2.5 配置切入点表达式和事务通知的对应关系、12&lt;!-- 在aop:config 标签内部：建立事务的通知和切入点表达式的关系 --&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt; 汇总1234567891011121314151617181920212223242526272829303132&lt;!-- 配置账户的持久层--&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源--&gt;&lt;context:property-placeholder location="db.properties"/&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;&lt;!--连接数据库的必备信息--&gt;&lt;property name="driverClass" value="$&#123;driverClass&#125;"&gt;&lt;/property&gt;&lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"&gt;&lt;/property&gt;&lt;property name="user" value="$&#123;jdbcUser&#125;"&gt;&lt;/property&gt;&lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务的通知--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置aop--&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式--&gt; &lt;aop:pointcut id="pt1" expression="execution(* com.lfc.service.impl.*.*(..))"&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 注解配置方式1.准备工作12&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package="com.lfc"/&gt; 数据源同xml配置 2.事务配置步骤2.1 配置事务管理器注入数据源12345&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2 业务层使用 @Transactional 注解1234567891011121314@Service("accountService")@Transactional(readOnly=true,propagation=Propagation.SUPPORTS)public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override @Transactional(readOnly=false,propagation=Propagation.REQUIRED) public void transfer(String id, String name) &#123; &#125;&#125; 该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。出现接口上，表示该接口的所有实现类都有事务支持。出现在类上，表示类中所有方法有事务支持出现在方法上，表示方法有事务支持。以上三个位置的优先级：方法&gt;类&gt;接口 2.3 配置文件中开启Spring对注解事务的支持12&lt;!-- 开启 spring 对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 纯注解式配置（不使用xml配置文件）主配置类 替代bean.xml1234567@Configuration //该类作为spring的xml配置文件中的&lt;beans&gt;@ComponentScan("com.lfc") //扫描配置包下被注解过的类@Import(&#123;JdbcConfig.class,TransactionConfig.class&#125;) //导入另外两个配置类@PropertySource("db.properties")@EnableTransactionManagement //事务注解public class SpringConfigurantion &#123;&#125; 数据源 配置类123456789101112131415161718192021222324252627282930313233public class JdbcConfig &#123; @Value("$&#123;driverClass&#125;") private String driver; @Value("$&#123;jdbcUrl&#125;") private String url; @Value("$&#123;jdbcUser&#125;") private String username; @Value("$&#123;password&#125;") private String password; @Bean(name = "jdbcTemplate") public JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125; /** * 创建数据源对象 * @return */ @Bean(name="dataSource") public DataSource createDataSource()&#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(username); ds.setPassword(password); return ds; &#125;&#125; 事务相关配置类123456public class TransactionConfig &#123; @Bean(name="transactionManager") public PlatformTransactionManager reateTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125;]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap多线程环境下死循环问题（记一次生产问题）]]></title>
    <url>%2F2019%2F08%2F04%2FHashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法与数据结构 一.问题今天在工作的时候项目组的同事说他们系统生产环境有线程stuck了，我抱着学习生产问题定位的心态凑合过去。了解到出现此问题时，操作员有多人使用同一帐号在系统中进行操作，且此种情况之前因为大批量的人员登录系统出现过。在拿到了报错日志时，在其中一段日志细节中突然发现了些许端倪。 下面连接防止图片连接失效备份图库（忽略）https://ws3.sinaimg.cn/large/006Xmmmgly1g5ke0d338mj31fl0gdwg3.jpghttps://img04.sogoucdn.com/app/a/100520146/0265cf53f113ead98c352ee1c3bec72a 来整理一下线索，由于多人使用同一帐号进行操作出现，且有大量人员登录进行操作时出现，联想到之前看耗子叔的一篇文章讲述关于多线程环境下操作map导致死循环问题，是否是因为HashMap在执行put的方法时线程阻塞了呢？ 二.定位在查看调用处的代码时发现，此处是cas-client的一个jar包。点开了jar包中SingleSignOutFilter这个类找到了其中doFilter方法123456789101112131415161718192021222324252627282930313233343536public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest)servletRequest; if ("POST".equals(request.getMethod())) &#123; String logoutRequest = request.getParameter("logoutRequest"); if (CommonUtils.isNotBlank(logoutRequest))&#123; if (log.isTraceEnabled()) &#123; log.trace("Logout request=[" + logoutRequest + "]"); &#125; String sessionIdentifier = XmlUtils.getTextForElement(logoutRequest, "SessionIndex"); if (CommonUtils.isNotBlank(sessionIdentifier)) &#123; HttpSession session = SESSION_MAPPING_STORAGE.removeSessionByMappingId(sessionIdentifier); if (session != null) &#123; String sessionID = session.getId(); if (log.isDebugEnabled()) &#123; log.debug("Invalidating session [" + sessionID + "] for ST [" + sessionIdentifier + "]"); &#125;try&#123; session.invalidate(); &#125; catch (IllegalStateException e) &#123; log.debug(e, e); &#125; &#125; return; &#125; &#125; &#125; else &#123; String artifact = request.getParameter(this.artifactParameterName); HttpSession session = request.getSession(); if ((log.isDebugEnabled()) &amp;&amp; (session != null)) &#123; log.debug("Storing session identifier for " + session.getId()); &#125; if (CommonUtils.isNotBlank(artifact)) &#123; SESSION_MAPPING_STORAGE.addSessionById(artifact, session); &#125; &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; 此代码反编译而成，语法稍有变化代码中的32行是引发报错的地方，根据SESSION_MAPPING_STORAGE 查看其代码定义处。1234private static SessionMappingStorage SESSION_MAPPING_STORAGE = new HashMapBackedSessionMappingStorage();public SingleSignOutFilter()&#123; this.artifactParameterName = "ticket";&#125; SESSION_MAPPING_STORAGE 的key值是获取的请求中的ticket，而value则是当前session，下面来看SESSION_MAPPING_STORAGE到底是个啥。12345678910111213141516171819202122232425262728public final class HashMapBackedSessionMappingStorage implements SessionMappingStorage&#123; private final Map MANAGED_SESSIONS; private final Map ID_TO_SESSION_KEY_MAPPING; public HashMapBackedSessionMappingStorage() &#123; this.MANAGED_SESSIONS = new HashMap(); this.ID_TO_SESSION_KEY_MAPPING = new HashMap(); &#125; public void addSessionById(String mappingId, HttpSession session)&#123; this.ID_TO_SESSION_KEY_MAPPING.put(session.getId(), mappingId); this.MANAGED_SESSIONS.put(mappingId, session); &#125; public void removeBySessionById(String sessionId)&#123; String key = (String)this.ID_TO_SESSION_KEY_MAPPING.get(sessionId); this.MANAGED_SESSIONS.remove(key); this.ID_TO_SESSION_KEY_MAPPING.remove(sessionId); &#125; public HttpSession removeSessionByMappingId(String mappingId) &#123; HttpSession session = (HttpSession)this.MANAGED_SESSIONS.get(mappingId); if (session != null) &#123; removeBySessionById(session.getId()); &#125; return session; &#125;&#125; SessionMappingStorage 是一个接口而HashMapBackedSessionMappingStorage 是它的实现类，其中11行addSessionById方法中的MANAGED_SESSIONS、ID_TO_SESSION_KEY_MAPPING都是使用的HashMap！且用final修饰，联想到此类在SingleSignOutFilter中使用时定义为static，自此找到问题所在。考虑到可能是由于jar包太过久远，查看了后续发布的jar包，其中对map操作时进行了加锁。下面连接防止图片连接失效备份图库（忽略）https://ws1.sinaimg.cn/large/006Xmmmggy1g5kdyihqz8j30uy0adt9q.jpghttps://i.loli.net/2019/08/01/5d42c85b65f4599497.jpg 三.分析为何HashMap在多线程环境下使用会有死循环问题呢？在此来回顾下其具体原理。 1.HashMap 是什么？hashMap是一个散列表，来源于数组，借助散列函数对数组进行了扩展，利用数组支持下标随机访问元素的特性进行存储。当key被加入的时候会通过散列函数计算出这个数组的下标i然后将这个&lt; key，value &gt;插入到array[i]中，如果有两个不同的key被计算到了同一个i的位置，叫做hash冲突，这时在数组i的位置会横向扩展成一个链表。（JDK1.8之前） 2.源码实现源码：put方法实现1、判断key是否已经存在1234567891011121314151617181920public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); // 如果key已经存在，则替换value，并返回旧值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // key不存在，则插入新的元素 addEntry(hash, key, value, i); return null;&#125; 2、检查容量是否达到阈值threshold12345678void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; 如果元素个数已经达到阈值，则扩容，并把原来的元素移动过去。3、扩容实现1234567891011void resize(int newCapacity)&#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; ...... //创建一个新的Hash Table Entry[] newTable = new Entry[newCapacity]; //将Old Hash Table上的数据迁移到New Hash Table上 transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor);&#125; 4、通过方法将数据迁移到扩容后的数组1234567891011121314151617181920212223void transfer(Entry[] newTable)&#123; Entry[] src = table; int newCapacity = newTable.length; //下面这段代码的意思是： // 从OldTable里摘一个元素出来，然后放到NewTable中 for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; //获得下一节点 Entry&lt;K,V&gt; next = e.next; //计算得到新数组下标位置 int i = indexFor(e.hash, newCapacity); //头插法，将当前节点next指向新数组，如果为空则为null，如果有值则获得其值 e.next = newTable[i]; //将数组赋值为新插入的链表头 newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125;&#125; 原链表值a-b-c-null ，使用头插法链表反转后循环结果依次为 a-null, b-a-null, c-b-a-nullok上述流程在单线程环境下是没有问题的，来看一下多线程场景。 3.多线程场景假设HashMap初始化大小为2，插入了三个节点，且三个都在同一hash槽内，此处设置其负载因子为1，元素数量达到3，此时触发了扩容。下面连接防止图片连接失效备份图库（忽略）https://ws2.sinaimg.cn/large/006Xmmmggy1g5la5c7yg3j30cw04zwea.jpg 插入第4个节点时，发生rehash，假设现在有两个线程同时进行，线程1和线程2，两个线程都会新建新的数组。https://ws1.sinaimg.cn/large/006Xmmmgly1g5la9qndm9j30ja08ddfp.jpg如果线程2 在执行到 Entry&lt;K,V&gt; next = e.next;之后，cpu时间片用完了，这时变量e指向节点a，变量next指向节点b。线程2继续执行，此时i 12345678910111213第一次循环移动节点a![第一次循环][5]https://ws2.sinaimg.cn/large/006Xmmmgly1g5las8g1pbj308p08pjr7.jpg第二次循环移动节点b![第二次循环][6]https://ws3.sinaimg.cn/large/006Xmmmgly1g5lav75hmej309d07y0sk.jpg使用的头插法，这里的顺序是反过来的继续移动节点c![第三次循环][7]https://ws2.sinaimg.cn/large/006Xmmmggy1g5laxk0dkrj30bj07ojr8.jpg在这个时候线程1的时间片用完，内部的oldTable还没有设置成新的数组， 线程2 开始执行。此时回顾下线程2时间片到了的时候变量e指向节点a，变量next指向节点b。**（注意此时因为线程1的干扰，这里的节点b.next已经不在指向c而是指向了a）** 1.首先插入节点a，e=next循环。Entry&lt; K,V &gt; next = e.next 此时next为a，e为b。再次插入节点b，e=next循环。2.第三次循环进来的时候执行完Entry&lt; K,V &gt; next = e.next; e为a节点，a的next指向null，next为null(循环退出条件)。3.e.next = newTable[i]; 此时newTable[i]指向节点b，链表节点依次为b-a-null。而e.next =b,就等于把a的next指向了b，这样a和b就互相引用了，形成了一个环。4.newTable[i] = e 把节点a放到了数组i位置此时链表节点依次为a-b-a（环）5.e=next 变量e=null 此时满足 while (e != null)条件，退出循环。`最终引用关系：https://ws1.sinaimg.cn/large/006Xmmmggy1g5lb4k5z52j30o609mq2x.jpg节点a和节点b的互相引用形成了一个环，当把当前newTable[i]赋值到原来的oldTable中时。数组在使用对应的get时就会发生死循环。并且因为a、b节点的互相引用也会导致c节点的丢失。 总结并发场景下，发生扩容时，可能会产生链表循环，在执行get时触发死循环，引起cpu100%，所以并发环境下一定要慎用HashMap。要并发可以使用线程安全的ConcurrentHashmap或者对map操作时加锁。 参考资料：coolshell 占小狼]]></content>
      <categories>
        <category>避坑指南</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>避坑指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spirng学习十一 - 事务管理]]></title>
    <url>%2F2019%2F07%2F28%2FSpirng%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%B8%80-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是事务Spring事务控制的目的是为了达到控制一组操作，要么都执行要么都不执行的一种操作。ACID四大特性: 原子性 ：最小执行单位，不可分割，要么都完成要么无效。 一致性 ：保证数据库数据整体完整性，事务成功则整体数据修改，事务失败则数据回滚到之前的状态。 隔离性 ：各事务之间是独立的，多个事务操作同一对象时，会串行等待方式执行，保证事务之间互不干扰。 持久性 ：事务提交后数据会保存到数据库，之后的数据基于此次保存的数据为基础。 Spring事务控制的API1.PlatformTransactionManager此接口是Spring的事务管理器。它提供了常用操作事务的方法。123456//获取事务状态信息TransactionStatus getTransaction(TransactionDefinition definition)//提交事务Void commit(TransactionStatus status) throws TransactionException; //回滚事务Void rollback(TransactionStatus status) throws TransactionException; 现实开发中使用的是它的实现类进行数据操作，具体有： org.springframework.jdbc.datasource.DataSourceTransactionManager 使用SpringJDBC 或者iBatis进行持久化数据时使用。 org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate进行持久化数据时使用。 org.springframework.orm.jpa.JpaTransactionManager 使用JPA进行持久化数据时使用。 org.springframework.transaction.jta.JtaTransactionManager 使用一个JTA来实现分布式事务管理，在一个事务跨越多个资源时使用。 2.TransactionDefinition事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，这个方法里面的参数是 TransactionDefinition类，这个类就定义了一些基本的事务属性。 方法如下：123456789101112public interface TransactionDefinition &#123;// 返回事务的传播行为int getPropagationBehavior(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据int getIsolationLevel(); // 返回事务超时时间int getTimeout();//返回事务的名字String getName()；// 返回是否为只读事务。 boolean isReadOnly();&#125; 1.并发事务影响事务的隔离级别反映并发操作时受其他事务影响的程度，其中可能带来的问题有： 脏读 ：又叫做读未提交，指的是当前事务对一数据进行了修改，但是并没有提交到数据库中，此时另一事务此时也访问了这个数据，并且使用了数据，而这时当前事务因为异常进行了数据回滚，此时另一事务读到的数据就是”脏数据”，根据脏数据是没法进行正确的操作的。 不可重复读 ：在一个事务内，多次读取同一数据，而两次读取数据中间由另一事务对当前数据进行了修改，导致两次读取数据的值不一样。 幻读 ： 与不可重复读类似，指的是，在一个事务内读取了若干行数据，接着另一事务插入了一些数据，并提交。在当前事务再次进行查询时会发现出现了一些本不存在的数据，就像幻觉一样。 值丢失 ： 在当前事务修改某一数据时，另一事务并发修改同一数据，导致晚提交的事务覆盖了上一提交的事务，造成值丢失。（例如 A=10，事务1更新A=A+20,事务2更新A=A-10,最后导致A=0的与预期值A=20不符） 幻读 和 不可重复读的区别：幻读重点在于新增和删除，而不可重复读的重点在于查询+修改。不可重复读 和 脏读的区别：脏读是当前事务读取了另一事务未提交的数据，而不可重复读是多次查询返回不同的数据值，因为当前数据被另一事务并发更改，并提交。 2.事务隔离级别数据库中定义了4种隔离级别,分别是： read uncommitted 读未提交 所有事务可以看到未提交事务数据。 read committed 读提交 只有事务提交后才可以被其他数据查询到。 Oracle 默认级别 repeatable read 可重复读 (会产生幻读) Mysql默认级别 Serializable 序列化 最高级别，强制事务按照顺序执行，在读的数据行上加上共享锁，可能产生大量的超时现象和锁竞争 TransactionDefinition接口定义了5个隔离等级的常量： ISOLATION_DEFAULT ： 默认 使用数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED ： 读未提交（可能会导致可能会导致脏读、幻读或不可重复读） ISOLATION_READ_COMMITTED 读已提交 （可避免脏读，不可避免幻读和不可重复读） ISOLATION_REPEATABLE_READ ：可重复读，同一字段多次读取结果一致，除非数据被本身事务进行修改（不可避免不可重复读） ISOLATION_SERIALIZABLE: 最高隔离界别 序列化操作（影响性能，慎用！） 3.事务传播事务方法被另一事务调用时，必须指定事务应该如何传播。事务的嵌套，内层事务既可以开启新的事务，也可以将当前事务合并到外层事务中来。具体有：支持当前事务型 PROPAGATION_REQUIRED：如果当前没有事务就新建事务，如果已有事务则加入该事务。 PROPAGATION_SUPPORTS：如果当前没有事务就加入该事务，如果没有事务，则以没有事务方式运行。 PROPAGATION_MANDATORY：如果当前存在事务加入该事务，如果没有事务则抛出异常。 不支持当前事务型 PROPAGATION_REQUIRES_NEW：创建一个新事物，如果当前存在事务，则挂起当前事务。 PROPAGATION_NOT_SUPPORTED：以没有事务方式运行，如果有事务则将当前事务挂起。 PROPAGATION_NEVER： 以非事务方式运行，如果存在事务则抛出异常。 其他 PROPAGATION_NESTED：当前存在事务，则创建事务作为当前事务的嵌套事务，如果没有则取值等价 PROPAGATION_REQUIRED。 PROPAGATION_NESTED 是Spring独有的，其启动的事务如果外部有事务的话内嵌于外部事务，此时内嵌事务不属于独立事务，它依赖外部事物，只有外部事物提交才能引起内部事务提交，内嵌子事务不得独立提交。当然外部事务回滚也会导致内部事务回滚。 4.超时时间超时时间指事务允许执行的最大时间，如果超过限制时间事务还没有完成，则自动回滚事务。默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 5.只读属性事务只读属性指当前事务对事务访问资源进行只读操作还是读写操作。只读操作可提高事务处理性能，可在适当的地方使用。 6.回滚默认情况下事务在运行期异常时会回滚，在检查型异常并不会回滚，但是可以声明事务遇到特定异常时回滚或不回滚，即使该异常是检查型异常。 3.TransactionStatusTransactionStatus 接口用来记录事务的状态，该接口定义了一组方法可以获得某个时间点上事务对象的状态信息。PlatformTransactionManager.getTransaction（）方法返回一个TransactionStatus对象，可能是一个新的事务或者已经存在的事务。接口方法如下： boolean isNewTransaction（） 是否新事务 boolean hasSavepoint（） 是否有恢复点 void flush（） 刷新事务 boolean isRollbackOnly() 是否回滚 void setRollbackOnly() 设置为只回滚 boolean isCompleted（）是否已完成* 配置方式XML配置方式1.准备工作jar包依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件约束配置导入aop和tx两个命名空间123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; 配置数据源12345678&lt;context:property-placeholder location="db.properties"/&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbcUser&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 2.事务配置步骤2.1 配置事务管理器123456&lt;!-- 配置一个事务管理器 --&gt;&lt;bean id="transactionManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;!-- 注入 DataSource --&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2 配置事务通知引用事务管理器123&lt;!-- 事务的配置 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;/tx:advice&gt; 2.3 配置事务属性1234567891011121314&lt;tx:attributes&gt;&lt;!-- 指定方法名称：是业务核心方法read-only：是否是只读事务。默认 false，不只读。isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。propagation：指定事务的传播行为。timeout：指定超时时间。默认值为：-1。永不超时。rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。--&gt;&lt;tx:method name="*" read-only="false" propagation="REQUIRED"/&gt;&lt;!-- REQUIRED 有事务就加入，没有则新建 --&gt;&lt;tx:method name="find*" read-only="true" propagation="SUPPORTS"/&gt; &lt;!-- 在这里对find开头的查询方法使用只读事务 ；SUPPORTS 当前有事务，则加入，没有则无事务--&gt;&lt;/tx:attributes&gt; 2.4 配置切入点表达式12345&lt;!-- 配置 aop --&gt;&lt;aop:config&gt;&lt;!-- 配置切入点表达式 --&gt;&lt;aop:pointcut expression="execution(* com.lfc.service.impl.*.*(..))" id="pt1"/&gt;&lt;/aop:config&gt; 2.5 配置窃取点表达式和事务通知的对应关系、12&lt;!-- 在aop:config 标签内部：建立事务的通知和切入点表达式的关系 --&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt; 汇总1234567891011121314151617181920212223242526272829303132&lt;!-- 配置账户的持久层--&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源--&gt;&lt;context:property-placeholder location="db.properties"/&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;&lt;!--连接数据库的必备信息--&gt;&lt;property name="driverClass" value="$&#123;driverClass&#125;"&gt;&lt;/property&gt;&lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"&gt;&lt;/property&gt;&lt;property name="user" value="$&#123;jdbcUser&#125;"&gt;&lt;/property&gt;&lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务的通知--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置aop--&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式--&gt; &lt;aop:pointcut id="pt1" expression="execution(* com.lfc.service.impl.*.*(..))"&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 注解配置方式1.准备工作12&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package="com.lfc"/&gt; 数据源同xml配置 2.事务配置步骤2.1 配置事务管理器注入数据源12345&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2 业务层使用 @Transactional 注解1234567891011121314@Service("accountService")@Transactional(readOnly=true,propagation=Propagation.SUPPORTS)public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override @Transactional(readOnly=false,propagation=Propagation.REQUIRED) public void transfer(String id, String name) &#123; &#125;&#125; 该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。出现接口上，表示该接口的所有实现类都有事务支持。出现在类上，表示类中所有方法有事务支持出现在方法上，表示方法有事务支持。以上三个位置的优先级：方法&gt;类&gt;接口 2.3 配置文件中开启Spring对注解事务的支持12&lt;!-- 开启 spring 对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习十-JDBCTemplate]]></title>
    <url>%2F2019%2F07%2F21%2FSpring%E5%AD%A6%E4%B9%A0%E5%8D%81-JDBCTemplate%2F</url>
    <content type="text"><![CDATA[JdbcTemplate简介上图是一个持久层的数据总图，详细的画出了各个层级之间的关系，首先最底层是常用的数据库，例如MySql、Oracle、SQLserver等，上面的一层是由各个数据库厂商提供的数据库驱动，再上面的一层就是常用的JDBC，对底层各个数据库实现细节进行屏蔽，使之可以统一的管理，连接。而JDBCTemplate则是Spring在JDBC的基础上对其进行了事务的支持,异常处理等的再封装,相当于一个工具类,它提供了很多的操作模版类。操作关系型数据库的 jdbcTemplate HibernateTemplate操作NoSql数据库的 RedisTemplate操作消息队列的JmsTemplate 使用准备需要使用jar包spring-jdbc ，还需要使用spring-tx 这个包包含了事务和异常的控制。12345678910 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 主要方法 execute 方式：可以用于执行任何sql语句，一般用来执行ddl语句。 update 和 batchUpdate方法：update用于执行增删改方法，batchUpdate用于执行批量处理。 query方法 用于执行查询相关操作。 call方法用于执行存过、函数。 使用方法创建配置文件db.properties1234jdbc.user=rootjdbc.password=rootjdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/mysql?serverTimezone=UTC spring配置文件1234567891011&lt;context:property-placeholder location="classpath:db.properties"/&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 代码测试1234567//启动IoC容器ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");//获取IoC容器中JdbcTemplate实例JdbcTemplate jdbcTemplate=(JdbcTemplate) ctx.getBean("jdbcTemplate");String sql="insert into user (name,deptid) values (?,?)";int count= jdbcTemplate.update(sql, new Object[]&#123;"caoyc",3&#125;);System.out.println(count);]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String优化知必会]]></title>
    <url>%2F2019%2F07%2F10%2FString%E4%BC%98%E5%8C%96%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[String 对象实现方式在众多版本中，String对象做了大量优化，下图是版本推进的演化过程： 1.在Java1.6之前的版本中，String对象是对char数组进行了封装实现的对象。2.而从Java1.7到1.8版本，Java对String类做了一些改变。String类不在有offset和count两个变量。3.从Java1.9开始，则将char[]字段改为了byte[]字段，又维护了一个新属性coder它是一个编码格式的标识。 那么为什么这样修改呢？如果仔细观察会发现一个char字符占16位，2字节。这个情况下，在存储拉丁语系的字符（占一个字节的字符）不需要太宽的char，这样无疑会很浪费，所以在1.9中为了节省内存，使用了占8位1字节的byte[]来存放字符串。（但是原来char[]时，字符串最大长度是数组本身长度的限制，在数组同样大小的前提下，byte[]存储能力理论上是退化了一倍的。） 而新属性 coder的作用是，在计算字符串长度或者使用indexOf()函数时，需要根据这个字段判断如何计算字符串长度，1代表UTF-16,0代表Latin-1(单字节编码)。 Java对象不可变性1.保证String的安全性，final修饰属性属性不可改变引用，修饰类则不可继承，这里防止了String类继承被篡改其中的某些方法。 2.线程安全性，在并发场景下，多个线程同时读一个资源，是不会引发竟态条件的。只有对资源做写操作才有危险。不可变对象不能被写，所以线程安全。 3.不可变可以实现字符串常量池，在创建String对象时通常有两种方式，String str = “abc”；另一种是String str = new String(“abc”);第一种方式创建字符串对象时，JVM会检查该对象是否在字符串常量池中，如果在，就返回对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象重复创建，节约内存。new String这种方式，首先在编译类文件时”abc”会被放入到常量结构中，类被加载时，”abc”将会在常量池中创建；在调用new时JVM调用String的构造函数，同时引用常量池中的”abc”字符串，在堆中创建一个String对象；最后将引用赋值给str。 对象优化1.拼装超长字符串在日常中如果使用String相加拼接字符串会产生多个对象么？例如： 1String str ="aa"+"bb"+"cc"; 理论上上述代码会先产生aa对象，再生成aabb对象，最后再生成aabbcc对象。但是实际运行过程中，发现只有一个对象生成，编译后的代码如下：1String str = "aabbcc"; 在大多数情况下java还是十分智能的，会自己优化实际代码，但是在循环中使用”+”拼接，会产生大量无意义的StringBuider对象,如下：12345String str = "abcdef";for(int i=0; i&lt;1000; i++) &#123; str = str + i;&#125; 反编译后：1234String str = "abcdef";for(int i=0; i&lt;1000; i++) &#123; str = (new StringBuilder(String.valueOf(str))).append(i).toString();&#125; 在此场景下应使用StringBuilder来避免循环中重复产生对象的行为（多线程场景下使用StringBuffer）。 2.合理使用String.intern节省内存在日常开发中字符串最长使用，但是其中很多都是重复的，如果能避免创建重复字符串，可以有效降低内存消耗和对象创建开销。 来看一段代码：12345678String str = new String("abc");s.intern();String str1 = "abc";System.out.println(s == s2);String s3 = new String("a") + new String("b");s3.intern();String s4 = "ab";System.out.println(s3 == s4); 上面这段代码的执行结果在不同版本的JDK下结果是不同的：JDK 1.6 : false falseJDK 1.7 : false true 在分析内容前先理解下常量池这个概念。 常量池指的是在编译期就已经被确定，并且被保存在已编译的class文件中的一些数据，它包括了关于类、方法、接口等中的常量，也包括字符串常量。 例如：1234567String s0="abc";String s1="abc";String s2="a"+"bc";String s3 = new String("abc");System.out.println( s0==s1 );System.out.println( s0==s2 );System.out.println( s0==s3 ); 结果： true true false 因为Java会保证字符串常量只有一个拷贝，s0和s1都是字符串常量，这个在编译期就可以确定了，所以s0==s1;而 s2中”a”和”bc”也都是字符串常量，当一个字符串由多个字符串常量组成，它本身肯定也是字符串常量，并且jvm编译时也会将代码”a”+”bc”优化成”abc”。new String() 创建的字符串不是常量，是在堆内存中开辟地址空间，所以new String()创建的字符串不放入常量池中,s0 != s3。 步入正题，来看一下String的intern()方法，它可以达到优化内存的作用，其效果在JDK1.6和1.7中表现并不一样来看下面这段代码：123456789101112String s = new String("1");s.intern();String s2 = "1";System.out.println(s == s2);String s3 = new String("a") + new String("b");s3.intern();String s4 = "ab";System.out.println(s3 == s4);String s5 = new String("ja") + new String("va");s5.intern();String s6 = "java";System.out.println(s5 == s6); 1.6运行结果：false false false;1.7及以上：true false false; 在1.6中，常量池在方法区，其位于臭名昭著的永久代，intern()会把首次遇到的字符串实例复制到永久代中，返回的也是这个永久代中字符串实例的引用，以此来达到，如果对字符串赋值，常量池中该值已存在则不会创建新的值，直接返回常量池中该值引用。（PermGen的空间是有限的,它主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，并且基本不会被FullGC之外的垃圾回收照顾到，所以如果有大量长字符串放入其中，OOM可能就会光顾。此方法1.6慎用！） 在1.7中，字符串常量池迁移到了heap中。 s3生成了三个最终对象常量池中的”a”，”b”和Heap中s3引用指向的对象。此时s3引用对象内容是”ab”，但是此时常量池中并没有”ab”。 (结合类加载过程，先在常量池中创建”a”,”b” 调用String构造函数生成两个匿名对象，然后进行字符串拼接最终对象) 接来下调用s3.intern()函数，将s3中的”ab” 放入到String常量池中，因为常量池中并没有此对象，则常量池直接存储了堆中的引用，直接指向了s3，也就是说引用地址相同。 最后String s4 =”ab” 是显示声明的，因此直接去常量池中创建，创建时发现已经存在该对象了，此时将指向s3 引用对象 的引用返回，s3 和 s4的引用一致 所以s3 == s4。 s和s2对象中 String s=new String(“1”);中生成了两个对象，常量池中的”1”和Heap中的字符串对象。s.intern()s去常量池中创建，发现”1”已存在。接下来s2=”1”显示声明时，直接返回了指向常量池中的对象，结果s！= s2。如图： 其中s5.s6的例子是练习中发现的一个坑，既其代码内容基本与s4一致，结果却不相同，经验证常量池中会维护一个常用的字符串常量池其中就有”java”字符串，所以使用了intern后直接将引用指向了默认对象，所以s5 != s6。 小结 将String常量池 从 Perm 区移动到了 Java Heap区 String.intern() 方法时，如果存在堆中的对象，会直接返回对象的引用，而不会重新创建对象. 适用场景1.Twitter在发布消息的时候，会产生一个地址信息，以当时用户规模预估服务器需要32G的内存来存储地址信息。1234567public class Location &#123; private String city; private String region; private String countryCode; private double longitude; private double latitude;&#125; 考虑到中间有很多用户地址信息是有重合的，比如，国家，省份，城市等，此时将这部分信息单独列出一个类，以减少重复。12345678910public class SharedLocation &#123; private String city; private String region; private String countryCode;&#125;public class Location &#123; private SharedLocation sharedLocation; double longitude; double latitude;&#125; 通过优化存储大小减到了20G左右，此时再利用了String.intern来节省内存，具体做法是，每次赋值时使用intern方法，如果常量池中有相同的值，就会重复使用该对象，一开始的对象就可以被回收掉。这种方式可以使重复性非常高的地址信息存储大小从20G降到几百兆。 12345678SharedLocation sharedLocation = new SharedLocation();sharedLocation.setCity(messageInfo.getCity().intern());sharedLocation.setCountryCode(messageInfo.getRegion().intern());sharedLocation.setRegion(messageInfo.getCountryCode().intern());Location location = new Location();location.set(sharedLocation);location.set(messageInfo.getLongitude());location.set(messageInfo.getLatitude()); 使用不当场景详看：https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习九-AOP]]></title>
    <url>%2F2019%2F06%2F30%2FSpring%E5%AD%A6%E4%B9%A0%E4%B9%9D-AOP%2F</url>
    <content type="text"><![CDATA[AOP概念1.什么是AOP？AOP：全称是 Aspect Oriented Programming 即：面向切面编程。简单来说AOP就是在程序中将重复的代码提取出来，在需要的时候，通过预编译方式运行时动态代理实现在不修改源代码的情况下，对已有的方法进行增强。 2.Spring AOP代理机制1.若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。 优点：因为有接口，所以使系统更加松耦合 缺点：为每一个目标类创建接口 2、若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。 优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。 缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。 3.相关术语Joinpoint( 连接点):所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。Pointcut( 切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。Advice( 通知/ 增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction( 引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或 Field。Target( 目标对象):代理的目标对象。Weaving( 织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。Proxy （代理）:一个类被 AOP 织入增强后，就产生一个结果代理类。Aspect( 切面):是切入点和通知（引介）的结合。 4.AOP基于xml配置使用前要明确先编写完成核心业务代码，然后把公用的代码抽取出来，制作成通知，然后在配置文件中声明切入点与通知的关系，及切面。具体步骤如下： 把通知Bean也交给spring来管理 使用aop:config标签表明开始AOP的配置 使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定通知类bean的Id。 在aop:aspect标签的内部使用对应标签来配置通知的类型 aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 aop:after-returning :后置通知，切入点方法执行后执行 aop:after-throwing ：异常通知，切入点方法产生异常时通知 aop:after :最终通知，无论是否切入点方法异常都会通知类似 finally切入点表达式的写法：关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) 标准的表达式写法： public void com.itheima.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法： * *..*.*(..) 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.service.impl.*.*(..) Maven导入aspectj包 切入表达式 12345678&lt;dependencies&gt; &lt;!-- 切入点表达式配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; xml配置1234567891011121314151617181920212223 &lt;context:annotation-config/&gt; &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.springAll.service.impl.AccountServiceImpl&quot;/&gt; &lt;!-- 配置logger类 --&gt; &lt;bean id=&quot;logger&quot; class=&quot;com.springAll.Logger&quot;/&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;&lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- 配置通知类型，简历通知方法和切入方法的关联 --&gt; &lt;aop:before method=&quot;beforePrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after-returning method=&quot;afterPrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-returning&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method=&quot;errorPrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-throwing&gt; &lt;!-- 最终通知 --&gt; &lt;aop:after method=&quot;finallyPrintLog&quot; pointcut=&quot;execution(* com.springAll.service.impl.*.*(..))&quot;&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试代码1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:applicationContext.xml")public class SpringAopTest &#123; @Resource private IAccountService accountService; @Test public void xmlAopTest()&#123; accountService.saveAccount(); accountService.updateAccount(); &#125;&#125; 但是每个切面中都需要有一个pointcut标签 配置切入点表达式，有些繁琐，所以这里可以将表达式提出来单独用标签来表示。1234567&lt;!-- 配置切面 --&gt;&lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!-- 配置通知类型，简历通知方法和切入方法的关联 --&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="log"&gt;&lt;/aop:before&gt; pointcut-ref="log"&gt;&lt;/aop:after&gt; &lt;aop:pointcut id="log" expression="execution(* com.springAll.service.impl.*.*(..))"/&gt;&lt;/aop:aspect&gt; 将aop:pointcut标签写在aop:aspect内部时，只有当前的切面可以使用，此时可以将其放到aop:config标签下，让其他的切入点也可以使用。（注：一定要将配置放到引用文件之前，不然没法使用。）12345678910&lt;aop:config&gt; &lt;aop:pointcut id="log" expression="execution(* com.springAll.service.impl.*.*(..))"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!-- 配置通知类型，简历通知方法和切入方法的关联 --&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="log"&gt;&lt;/aop:before&gt; &lt;!-- 最终通知 --&gt; &lt;aop:after method="finallyPrintLog" pointcut-ref="log"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 在上面讲了后置通知，前置通知，异常通知，和最终通知，最后再来看环绕通知。12 &lt;!-- 环绕通知 --&gt;&lt;aop:around method="aroundPrintLog" pointcut-ref="log"/&gt; Spring框架提供了一个接口ProceedingJoinPoint，此接口有一个方法proceed（）。相当于明确调用切入点方法。该接口可以作为环绕通知的方法参数，在程序执行时，Spring框架会提供该接口实现供我们使用。123456789101112131415public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object returnVal = null; try &#123; Object obj[] = pjp.getArgs(); //得到方法执行所需的参数 System.out.println("===============Logger类记录开始日志================ 前置"); returnVal = pjp.proceed(); //切入点方法 System.out.println("===============Logger类记录开始日志================ 后置"); &#125; catch (Throwable throwable) &#123; System.out.println("===============Logger类记录开始日志================ 异常"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("===============Logger类记录开始日志================ 最终"); &#125; return returnVal;&#125; 以上流程就叫做环绕通知，既可以定制化的决定使用何种通知，且可以在其中决定是否调用目标方法！！！在前置等其他通知中是不可以的，只是在方法调用前后执行通知而已。 环绕通知也可以控制返回对象，既可以返回一个与目标对象方法完全不同的对象！ 5.AOP基于注解xml开启注解AOP的支持1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 添加 @Aspect 表示当前类为切面类使用 @Pointcut 来指定切入点表达式。（此注解需要引入jar包aspectjweaver 最好是1.8以后的，之前使用的1.5的使用注解时报错了，需注意）123456789101112131415161718192021222324252627282930313233343536373839404142@Component("logger")@Aspect//表示当前类是一个切面类public class Logger &#123; @Pointcut("execution(* com.springAll.service.impl.*.*(..))") private void pt1()&#123;&#125; /** * 用于打印日志切入点方法之前执行 */ // @Before("pt1()") public void beforePrintLog()&#123; System.out.println("===============Logger类记录开始日志================"); &#125; @AfterReturning("pt1()") public void afterPrintLog()&#123; System.out.println("===============Logger类记录结束日志================"); &#125; @AfterThrowing("pt1()") public void errorPrintLog()&#123; System.out.println("===============Logger类记录异常日志================"); &#125; @After("pt1()") public void finallyPrintLog()&#123; System.out.println("===============Logger类记录最终日志================"); &#125;//@Around("pt1()") public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object returnVal = null; try &#123; Object obj[] = pjp.getArgs(); //得到方法执行所需的参数 System.out.println("===============Logger类记录开始日志================ 前置"); returnVal = pjp.proceed(); //切入点方法 System.out.println("===============Logger类记录开始日志================ 后置"); &#125; catch (Throwable throwable) &#123; System.out.println("===============Logger类记录开始日志================ 异常"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("===============Logger类记录开始日志================ 最终"); &#125; return returnVal; &#125;&#125; 执行结果：1234===============Logger类记录开始日志================执行保存===============Logger类记录最终日志===============================Logger类记录结束日志================ 此时发现执行结果的顺序有些问题，最终日志竟然输出在了结束日志的前面，经查spring注解aop中存在调用顺序异常的问题，所以在实际开发中可以考虑使用xml配置的方式或者使用注解的环绕通知，因为具体调用顺序由程序决定，所以不会有此问题。 练习资源]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习八-之动态代理]]></title>
    <url>%2F2019%2F06%2F23%2FSpring%E5%AD%A6%E4%B9%A0%E5%85%AB-%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、问题来源在进行软件设计的时候往往会将一个大的系统按照业务模块拆分成一个个的低耦合、高内聚的模块，分而治之。如图：拆分后发现一些问题，这些问题是通用的，跨模块的。比如：1.日志：对执行某些操作分支判断时输出日志。2.安全：在执行某些操作前进行权限检查。3.事务：在方法开始前开始事务，方法结束时提交或者回滚事务。4.性能统计：统计某些方法的执行时间。以上这些属于非功能型需求，是多个业务模块都需要的，那么应该如何去写呢？ 1.常规解决方法1234567891011121314151617181920public class Command &#123; public void execute()&#123; Logger logger = Logger.getLogger(""); //1.记录日志 logger.info("XXXX"); //2.性能统计 Long startTime = System.nanoTime(); //3.权限检查 if(!user.hasPreviledge())&#123; //抛出异常阻断流程 &#125; //4.开始事务，进行增删改操作 ------业务代码------- //提交事务 commitTransaction(); Long endTime = System.nanoTime(); logger.info("xxxxx"); &#125;&#125; 上面的代码虽然解决了问题，但是使用起来十分不爽，日志、安全、性能、事务等代码都耦合到了业务代码中，使一个简单的业务逻辑模块代码都异常的复杂，且重复代码充斥在各个业务逻辑中。 那么如何解决解决痛点呢？ 1.设计模式：模版方法首先先来回顾下模版方法：模版模式是当不变的和可变的行为混在一起的时候通过把不变的行为提取到超类并且定义一个算法的骨架，去除子类中的重复代码，以此摆脱重复不变行为的纠缠。一堆啰嗦的话，还是看下具体实现：12345678910111213141516171819202122232425262728293031323334//定义超类模版公共部分public abstract class Command &#123; public void execute()&#123; Logger logger = Logger.getLogger(""); //1.记录日志 logger.info("XXXX"); //2.性能统计 Long startTime = System.nanoTime(); //3.权限检查 if(!user.hasPreviledge())&#123; //抛出异常阻断流程 &#125; //4.开始事务，进行增删改操作 //5.业务代码操作交由具体子类独自实现 doBusiness(); //提交事务 commitTransaction(); Long endTime = System.nanoTime(); logger.info("xxxxx"); &#125; //具体业务实现，交给对应模块的子类 public abstract void doBusiness();&#125;class PlaceOrderCommand extends Command&#123; public void doBusiness() &#123; //执行订单操作 &#125;&#125;class PaymentCommand extends Command&#123; public void doBusiness() &#123; //执行支付操作 &#125;&#125; OK，这样一来，代码看起来清爽了好多，各种无关业务的代码在子类中也不复存在了。调用也很简单，例如：12Command cmd = new PlaceOrderCommand();cmd.execute(); 总结：仔细观察可以发现，使用这个方法会导致超类会定义所有的操作，要执行哪些非功能性代码，以什么顺序，等等。子类只能默默接受，那么有没有什么方法可以让子类达到定制化的效果，比如只需要进行事务的支持，其他的不需要。 2.设计模式：装饰者模式内容复习：装饰者模式可以动态的给一个对象添加一些额外的职责，有效的区分类的核心职责就增加功能而言，装饰者模式比生成子类更加灵活。废话不多说，上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface Command &#123; public void execute();&#125;/** * 日志类 */public class LoggerDecorator implements Command &#123; Command cmd; public LoggerDecorator(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; Logger logger = Logger.getLogger(""); logger.info("记录日志start"); this.cmd.execute(); logger.info("记录日志end"); &#125;&#125;/** * 性能统计 */ class PerformanceDecorator implements Command &#123; Command cmd; public PerformanceDecorator(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; PerformanceUtil.startTimer(); this.cmd.execute(); PerformanceUtil.endTimer(); &#125;&#125;/** * 执行订单操作，具体业务代码 */class PlaceOrderDecorator implements Command &#123; Command cmd; public PlaceOrderDecorator(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; //执行支付 &#125;&#125; 现在就像递归一样层层调用，可以自由的决定让PlaceOrderDecorator可以选择打印日志或者性能统计等等。123Command cmd = new LoggerDecorator(new PerformanceDecorator(new PlaceOrderDecorator()));cmd.execute(); 如果只需要其中部分功能只需要实例化对应的模块即可，例如只需要订单操作时打印日志123Command cmd = new LoggerDecorator(new PlaceOrderDecorator());cmd.execute(); 总结：装饰者模式虽然可以通过装饰器灵活的使用各种方法，但是由此也带出了两个问题：1.一个处理日志/安全/事务/性能统计的类为什么要去实现业务接口呢？2.如果其他模块没有实现业务接口，但是想使用日志/安全/事务/性能统计等功能，那该怎么办呢？ 3.代理模式Ⅰ.介绍：为其他对象提供一种代理以此来控制这个对象的访问，使客户端不直接引用对象，很好的在客户端和目标对象之间起到中介的作用。 Ⅱ.适用场景： 远程代理，为一个对象在不同的地址空间提供局部代表。这样即使远程方法在服务器，但是本地调用其代理类，内部屏蔽了远程调用过程，对于客户端而言与本地方法无异。（如：webService） 虚拟代理，占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。（比如：HTML加载时，有很多图片，为了及时的响应页面，可以先将图片位置展示代理对象，待缓存完成时，再展示出来；当一个对象加载耗费资源很大时，利用虚拟代理，将那些耗费资源的操作直到具体使用时再加载，在此之前使用虚拟代理对象来代替。可达到资源重用，节省内存，以时间换空间。；参考浏览器加载可在因io阻塞导致对象加载缓慢的时候，结合多线程技术先行一步创建加载较快的代理对象，另起线程加载真实对象，先行返回代理对象，当调用真实对象时，此时资源可能已经加载完毕，以此来加快相应时间。） 安全代理, 也叫保护代理，用来控制真实对象访问时的权限，如果有必要的话，可以给不同调用者提供不同的权限。 智能指引,是指当调用真实对象时，代理处理另外一些事，比如记录对此对象的调用次数等。 了解了代理模式及使用场景后，此处我们使用其中的智能指引的这种场景，既在代理类中对被代理的类添加一些功能。 代码：1234567891011121314151617181920212223242526272829public interface Command &#123; public void execute();&#125;public class PlaceOrderDecorator implements Command &#123; public void execute() &#123; System.out.println("执行支付"); &#125;&#125;/** * 代理类 */ class CommandProxy implements Command &#123; Command cmd; public CommandProxy(Command cmd) &#123; this.cmd = cmd; &#125; public void execute() &#123; System.out.println("记录日志start"); this.cmd.execute(); System.out.println("记录日志end"); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Command cmd = new CommandProxy(new PlaceOrderDecorator()); cmd.execute(); &#125;&#125; 总结： 1、代理模式可以在不修改初始类的前提下对其功能进行了增强。 2、接口中有多少方法，在proxy层就得实现多少方法，有多少方法就要开启和提交多少事务，代码繁琐复杂。 3、如果一个proxy实现了多个接口，如果其中的一个接口发生变化（添加了一个方法），那么proxy也要做改变。 4、静态代理模式并没有做到日志的重用 由此引出今天的主角，动态代理。 4.动态代理Ⅰ、JDK动态代理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class Interceptor implements InvocationHandler&#123; Transaction transaction; Object target; public Interceptor(Transaction transaction, Object target) &#123; this.transaction = transaction; this.target = target; &#125; /** * @param proxy 目标对象的代理类实例 * @param method 对应于在代理实例上调用接口方法的Method实例 * @param args 传入到代理实例上方法参数值的对象数组 * @return 方法的返回值，没有返回值是null * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); if("execute".equals(methodName))&#123; transaction.beginTransaction(); method.invoke(target); transaction.commit(); &#125;else&#123; method.invoke(target); &#125; return null; &#125;&#125;/** * 事务类 */class Transaction&#123; void beginTransaction()&#123; System.out.println("******** 开启事务 **************"); &#125; void commit()&#123; System.out.println("********* 提交事务 ************"); &#125;&#125;/* * 测试类*/@Test public void testSave()&#123; /** * 1、创建一个目标对象 * 2、创建一个事务 * 3、创建一个拦截器 * 4、动态产生一个代理对象 */ Object target = new PlaceOrderDecorator(); Transaction transaction = new Transaction(); Interceptor proxy = new Interceptor(transaction,target); /** * 参数一：设置代码使用的类加载器，一般采用跟目标类相同的类加载器 * 参数二：设置代理类实现的接口，跟目标类使用相同的接口 * 参数三：设置回调对象，当代理对象的方法被调用时，会调用该参数指定对象的invoke方法 */ Command com = (Command) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(),proxy); com.execute(); &#125; 基于上述流程进行优化：12345678910111213141516171819202122232425262728293031323334public class ProxyFactory &#123; Transaction transaction = new Transaction(); Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; /** * 生成代理类 */ public Object getProxyInstance ()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); if("execute".equals(methodName))&#123; transaction.beginTransaction(); method.invoke(target,args); transaction.commit(); &#125;else&#123; method.invoke(target); &#125; return null; &#125; &#125;); &#125;&#125; @Test public void testProxy()&#123; Object target = new PlaceOrderDecorator(); Command com = (Command)new ProxyFactory(target).getProxyInstance(); com.execute(); &#125; 总结：静态代理与动态代理的区别： 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件。 动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中。 特点： 因为使用了JDKProxy生成的代理类实现了接口，所以目标类中所有的方法在代理类中会有。 动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。 invoke方法中的三个参数可以访问目标类的被调用方法的API、被调用方法的参数、被调用方法的返回类型。 缺点： 1.在拦截器中除了能调用目标对象的目标方法之外功能比较单一。 2.在使用拦截器中的invoke方法的if判断语句进行功能增强的时候具体实施时因为要支持日志/安全/事务/性能统计等功能，if语句需要写很多，这无疑是个灾难。 Ⅰ、CGLIB动态代理123456789101112131415161718192021222324252627282930313233343536public class CglibProxyFactory implements MethodInterceptor&#123; private Object target; Transaction transaction; public CglibProxyFactory(Object target, Transaction transaction) &#123; this.target = target; this.transaction = transaction; &#125; public Object getProxyInstance()&#123; //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 拦截调用intercept函数 en.setCallback(this); //创建子类对象代理 return en.create(); &#125; public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; transaction.beginTransaction(); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); transaction.commit(); return null; &#125;&#125;//测试类 @Test public void testCGlibProxy()&#123; PlaceOrderDecorator target = new PlaceOrderDecorator(); System.out.println(target.getClass()); PlaceOrderDecorator proxy = (PlaceOrderDecorator)new CglibProxyFactory(target,new Transaction()) .getProxyInstance(); System.out.println(proxy.getClass()); proxy.execute(); &#125; 输出结果： 12345class PlaceOrderDecoratorclass PlaceOrderDecorator$$EnhancerByCGLIB$$640bbc4f******** 开启事务 **************执行支付********* 提交事务 ************ 总结：1.JDK动态代理需要目标对象和代理对象实现业务接口，拦截器需要实现InvocationHandler接口，其中invoke方法体中内容是具体代理对象方法体内容。2.CGlib代理的目标类不需要实现接口，代理类是目标类的子类，拦截器需要实现MethodInterceptor接口，其中重写intercept方法时，进行具体功能增强操作。但是因为cglib是依靠继承目标对象重写其方法，所以目标对象不得是final类！！！ 练习资源]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习七-Spring整合Junit的配置]]></title>
    <url>%2F2019%2F06%2F16%2FSpring%E5%AD%A6%E4%B9%A0%E4%B8%83-Spring%E6%95%B4%E5%90%88Junit%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[问题：在Junit测试时，在将通用的bean注入提到方法外面形成全局变量时，在运行测试类代码时，会无法注入bean对象。在Junit单元测试中，没有main方法也能执行，其实是因为Junit集成了一个main方法，该方法会判断当前测试类哪些方法使用了@Test注解，Junit会让有注解的方法执行，但是Junit不会探测是否使用了Spring框架，在执行方法时也不会读取配置文件创建Spring核心容器，所以在Junit中没有没有ioc容器就算写了Autowired注解，bean对象也没办法注入。 方法：Spring整合Junit的配置1.导入spring整合junit的配置2.使用junit提供的注解把原有的runner方法替换为Spring提供的@Runwith3.告知Spring运行器，spring和IOC创建是基于注解的还是xml配置的，描述文件位置。4.@ContextConfiguration locations：指定xml文件的位置，加上classpath关键字，标识在类路径下 classes：指定注解类所在的地址注：当使用spring5.x版本的时候，要求junit的版本必须是4.12及以上123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration(locations = "classpath:applicationContext.xml")@ContextConfiguration(classes = Car.class)public class SpringTest &#123; @Autowired private Car car; @Test public void testFindAll()&#123; car.produce(); System.out.println("收拾收拾"); &#125; 练习资源]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习六-注解IOC]]></title>
    <url>%2F2019%2F06%2F15%2FSpring%E5%AD%A6%E4%B9%A0%E5%85%AD-%E6%B3%A8%E8%A7%A3IOC%2F</url>
    <content type="text"><![CDATA[基本配置@Component 注解是用于创建bean对象的，但是只使用@Component注解是无法使用的，需要在配置文件中去声明，告知spring在创建容器时要扫描的包，配置所需要的标签不是在bean的约束中，而是一个mingcheng为context名称空间和约束中1&lt;context:component-scan base-package="com.how2java.pojo"/&gt; 且在beans的头信息中需要导入如下信息12xmlns:aop="http://www.springframework.org/schema/aop"xmlns:context="http://www.springframework.org/schema/context" 详解：用于创建bean对象的他们的作用就和xml配置文件中编写一个bean标签实现的功能是一样的@Component 作用：用于把当前的对象放入到spring容器中。 属性： value:用于指定bean的id，如果不写beanname默认是当前类名，首字母小写。 Controller：一般用于表现层 Service:一般用于业务层 Respository:一般用于持久层以上三个注解的作用和属性和Component是一样的，他们三个是用来提供明确的三层使用的注解，使结构更加清晰。 ###用于注入数据的作用相当于xml配置文件中的bean标签中写一个标签Autowired: 作用：自动按照类型注入，只要有容器中有唯一的一个bean对象类型和要注入的变量类型匹配就可以成功。 1. 如果没有匹配类型则产生异常 2. 如果被spring管理的有多个相同类型对象则按照参数去匹配beanid如果匹配到就成功加载，匹配不到则抛出异常 出现位置：可以是方法上也可以是变量上。（无需有set方法） Qualifier : 作用:按照名称注入，在给类成员注入时不得单独使用(需和Autowired搭配使用)，但是给参数注入时可以使用。 属性： value:用于指定注入bean的id. Resource 作用：直接按照bean的id注入，可以独立使用 属性：name：用于指定bean的id以上三个注入类型都只能注入bean类型的数据，基本类型和string类型无法注入，另外集合类型注入只能通过xml注入。 Value: 作用：用于注入基本类型和String类型的数据 属性： value:用于指定数据的值，它可以使用SpEL（srping的EL表达式） 写法：$｛表达式｝ 用于改变作用范围的Scope 作用：用于指定bean的作用范围 属性： value：指定范围的取值。常用取值：singleton prototype 声明周期相关PreDestroy 作用：指定销毁方法 PostConstruct 作用：指定初始化方法 利用配置类来代替xmlConfiguration 作用：指定当前类是一个配置类ComponentScan 作用：通过注释指定spring在创建容器时要扫描的包 属性： value：作用和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包路径。等同于在xml配置了：1&lt;context:component-scan base-package="com.how2java.pojo"/&gt; 1234@Configuration@ComponentScan(value = "com.how2java.pojo")public class SpringConfig &#123;&#125; Bean 作用：用于把当前方法的返回值放入到spring容器中。 属性： name：用于指定bean的id，不写时默认id是当前方法名。 细节：当使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找方式和Aturowired方式是一样的，如果类型一样且只有一个对象就注入。123456789101112131415161718@Configuration@ComponentScan(value = "com.how2java.pojo")public class SpringConfig &#123; @Bean(name ="c") public Category getCategory(Product p)&#123; return new Category(); &#125; @Bean(name = "p") @Scope("prototype")//多例对象 public Product getProduct()&#123; return new Product(); &#125;&#125;//测试类ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);Product d = (Product) context.getBean("p"); import 作用：用于导入其他的配置类 属性： value:用于指定其他配置类的字节码 当使用import的注解以后，有import的类就是父配置类，导入的类是子配置类。12345678910111213141516@Configuration@ComponentScan(value = "com.how2java.pojo")@Import(SpringBean.class)public class SpringConfig &#123;&#125;public class SpringBean &#123; @Bean(name ="c") public Category getCategory(Product p)&#123; return new Category(); &#125; @Bean(name = "p") @Scope("prototype") public Product getProduct()&#123; return new Product(); &#125;&#125; PropertySource 作用：指定Propertys文件的位置 属性： value:用于指定文件的名称和路径。 关键字：classpath： 表示类路径下123456789101112@Configuration@ComponentScan(value = "com.how2java.pojo")@Import(SpringBean.class)@PropertySource("classpath:config.properties")public class SpringConfig &#123;&#125;//使用方式el表达式 @Value("$&#123;product.name&#125;") private String name; @Value("$&#123;product.no&#125;") private String no;]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spirng学习五-依赖注入的几种方式]]></title>
    <url>%2F2019%2F06%2F10%2FSpirng%E5%AD%A6%E4%B9%A0%E4%BA%94-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在学习的第一天就跟着demo练习了一番spring依赖注入的具体操作，在接下来的几天对于为什么要这么做有了一定的认识，今天对于依赖注入的具体方式来进行一下细分。 一、构造函数注入通过构造函数来进行依赖关系的设定，默认是使用的无参构造，如果重写了构造函数改成带参数的而没有无参构造，直接使用如下注入会失败。12345678String name;Integer price;Date byDate;public Car(String name, Integer price, Date byDate) &#123; this.name = name; this.price = price; this.byDate = byDate;&#125; 1&lt;bean name="car" class="com.pojo.Car" &gt;&lt;/bean&gt; 运行后错误提示1Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'car' defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.pojo.Car]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.pojo.Car.&lt;init&gt;() 配置这个时候如果要使用构造器注入对应的属性应该使用标签constructor-arg来注入有参构造的参数。其中的属性如下： type:通过指定要注入数据的数据类型，该数据类型也是构造函数中某个参数的类型（同参数类型的参数会引起混乱） index:用于指定要注入数据给构造函数中指定索引位置的参数赋值，索引位置是从0开始。 name:用于指定给构造函数中指定名称的参数赋值（常用） 赋值类型： value:基本类型和String类型赋值 ref：用于指定其他的bean类型数据（交给spring管理的bean对象） 代码示例12345 &lt;bean name="car" class="com.pojo.Car" &gt; &lt;constructor-arg name="name" value="雷克萨斯"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="price" value="600000"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="byDate" value="2018-1-1"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 此处Integer类型直接使用value可以将写入的值进行转换，但是Date类型并不会进行转换。提示如下：1Could not convert argument value of type [java.lang.String] to required type [java.util.Date]: Failed to convert value of type 'java.lang.String' to required type 'java.util.Date' 正确的写法应该先配置一个日期对象然后使用ref引用改对象对其进行赋值。123456&lt;bean name="car" class="com.pojo.Car" &gt; &lt;constructor-arg name="name" value="雷克萨斯"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="price" value="600000"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="byDate" ref="newDate"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name="newDate" class="java.util.Date"&gt;&lt;/bean&gt; 总结：优势：获取对象时，注入必须的操作否则对象没法创建成功。弊端：改变了bean对象的实例化方式，如果创建对象用不到的数据，但是也必须提供。 方法注入（常用）配置标签：property位置：bean标签内部属性： name：用于指定注入时所调用的set方法名称（注意是set方法名称，与变量名无关） value:用于提供基本类型和String类型的数据 ref:用于指定其他的bean类型数据。（交给spring管理的bean对象） 代码示例1234567891011121314public class Car &#123; String name; Integer price; Date byDate; public void setName(String name) &#123; this.name = name; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125; public void setByDate(Date byDate) &#123; this.byDate = byDate; &#125;&#125; 调用set方法，使用默认无参构造函数。12345&lt;bean name="car" class="com.pojo.Car" &gt; &lt;property name="name" value="梅赛德斯"/&gt; &lt;property name="byDate" ref="newDate"/&gt; &lt;property name="price" value="1000000"/&gt;&lt;/bean&gt; 总结优势：创建对象时没有明确限制，可以直接使用默认的构造函数弊端：如果某个成员必须有值，获取对象时有可能set方法还没有执行。 复合类型注入对于参数是集合类型的注入方法 配置标签：还是使用的set注入的标签property位置：bean标签内部 代码示例123456789101112131415161718public class Car &#123; String[] strs; List list; Map map; Set set; public void setList(List list) &#123; this.list = list; &#125; public void setMap(Map map) &#123; this.map = map; &#125; public void setStrs(String[] strs) &#123; this.strs = strs; &#125;&#125; public void setSet(Set set) &#123; this.set = set; &#125; 1234567891011121314151617181920212223242526 &lt;bean name="car" class="com.pojo.Car" &gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="set"&gt; &lt;set&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="strs"&gt; &lt;array&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="no1" value="abc"&gt;&lt;/entry&gt; &lt;entry key="no2" value="qwe"&gt;&lt;/entry&gt; &lt;entry key="no3" value="zxc"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; 但是在使用时发现关于list 、set 、数组类型的时候因为数据结构类型的类似，标签使用同一个也是可以注入的。例：1234567891011121314151617181920212223242526&lt;bean name="car" class="com.pojo.Car" &gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="set"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="strs"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="no1" value="abc"&gt;&lt;/entry&gt; &lt;entry key="no2" value="qwe"&gt;&lt;/entry&gt; &lt;entry key="no3" value="zxc"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; 总结：关于集合类型的注入其实就分为两种一种是list（也可以使用set、array）、一种是map、props的键值类型，类型相同标签可以互换。]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spirng学习四-SpringBean的作用域]]></title>
    <url>%2F2019%2F06%2F09%2FSpirng%E5%AD%A6%E4%B9%A0%E5%9B%9B-SpringBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Bean注入的三种方式1：使用默认的构造函数在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时采用的就是默认的构造函数常见bean对象，此时如果没有默认构造函数则对象无法创建。1&lt;bean name="car" class="impl.Car"/&gt; 2.使用普通工厂的方法创建对象（使用某个类中的方法创建对象，交给spring管理）比如jar包中的class中某个方法创建了一个对象现在希望通过它来获得对象交给spring管理12345public class BeanFactory2 &#123; public Car getCar()&#123; return new Car(); &#125;&#125; 首先将该类交给Spring管理，之后通过beanName指定该类通过factory-method指定通过该类中getCar方法获得对象。12 &lt;bean name="factory" class="com.factory.BeanFactory2"&gt;&lt;/bean&gt;&lt;bean name="factoryCar" factory-bean="factory" factory-method="getCar"&gt;&lt;/bean&gt; 3.使用工厂中的静态方法创建对象基于上面的工厂方法获得对象，在工厂类的方法是static修饰的静态方法的时候可以直接通过如下配置加载。1&lt;bean name="factoryCar" class="com.factory.BeanFactory2" factory-method="getCar"&gt;&lt;/bean&gt; Bean的作用域在Spring容器中一共提供了五种作用域类型，在配置文件中通过属性scope来设置bean的作用域范围。 1.默认 singleton：单例1&lt;bean name="car" class="impl.Car" scope="singleton"/&gt; 在对scope没有设置的时候bean默认就是单例的，多次获取同一个id都是一个bean的实例。 1234//此时容器初始化完毕后可以取里面的bean了. Car car1 = (Car)bf.getBean("car"); Car car2 = (Car)bf.getBean("car"); System.out.println(car1 == car2); 执行结果：12小汽车被加载了true 2. prototype：多例]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习三-ApplicationContext]]></title>
    <url>%2F2019%2F06%2F05%2FSpring%E5%AD%A6%E4%B9%A0%E4%B8%89-ApplicationContext%2F</url>
    <content type="text"><![CDATA[Spring中的Resource接口 在Spring内部实现机制，针对于资源文件(配置的xml文件)有一个统一的接口Resource。 Resource具体实现类： ClassPathResource:类路径下的资源，位置在classes路径下 FileSystemResource:文件系统资源，资源以文件系统路径的方式表示，如：D:/File/conf.xml; InputStreamResource:对应一个InputStream的资源 ServletContextResource:访问web容器上下文中资源的类，负责以相对于web应用根目录的路径加载资源，支持以流和URL的方式访问。 UrlResource :用户能够访问任何可以通过URL表示的资源。如http资源，ftp资源。 Spring的资源类型的地址前缀地址前缀对应资源类型 classpath:从类路径中加载资源，相对于类的根路径。 file:使用URLResource从文件系统目录中装载资源。 http://：使用URLResource从web服务器中装载资源。 ftp://:使用URLResource从ftp服务器中装载资源。 无前缀：根据ApplicationContext具体实现类采用对应类型的Resource。在web项目中可以使用Resource 来代替java的IO来获取资源，并且还支持Ant通配符。Ant风格: ?:匹配文件名中的一个字符. *:匹配文件命中的任意字符. ** :匹配多层路径.示例：123456789101112131415161718192021PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; Resource[] res = resolver.getResources("classpath:/test.txt"); for (Resource resource : res)&#123; System.out.println(resource.getDescription()+"----"+resource.getFilename()); //System.out.println(resource.getFile().); BufferedReader bf = new BufferedReader(new FileReader(resource.getFile())); String data = ""; while((data = bf.readLine())!=null)&#123; System.out.println(data); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (null != bf)bf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 输出结果12class path resource [test.txt]----test.txtspringResource加载 BeanFactory和ApplicationContextBeanFactoryBeanFactory 是延迟加载，如果bean的某一属性没有注入，BeanFactory加载后，直到调用getBean方法的时候才会抛出异常，而ApplicationContext在初始化的时候会进行校验，这样有利于检查依赖的属性是否注入。且ApplicationContext继承自Beanfactory，其实现更为丰富，故通常我们选择使用ApplicationContext。初始化Beanfactory的例子：123456789101112//调用资源加载器加载Spring配置文件 PathMatchingResourcePatternResolver resolver=new PathMatchingResourcePatternResolver(); Resource res =resolver.getResource("classpath:/applicationContext.xml"); DefaultListableBeanFactory bf =new DefaultListableBeanFactory(); //BeanDefinition 读取器,专门读取资源到容器 XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(bf); //读取资源进到容器 reader.loadBeanDefinitions(res); //此时容器初始化完毕后可以取里面的bean了. bf.getBean("car"); ApplicationContext主要类和接口ApplicationEventPublisher: 让容器拥有发布应用程序上下文事件的功能.ResourcePatternResolver:实现了类似于资源加载器的功能，能够识别特定前缀加Ant风格的路径并加载到容器中.LifeCycle：管理容器中bean的生命周期。ConfigurableApplicationContext:主要新增了refresh()和close()方法，让ApplicationContext有用了启动，关系和刷新上下文的功能。ClassPathXmlApplicationContext与FileSystemXmlApplicationContext:Spring提供的两个常用的ApplicationContext实现类，前者默认从类路径加载配置文件，后者从文件系统加载。然后初始化一个ApplicationContext看看:12ApplicationContext ac =new ClassPathXmlApplicationContext("application.xml");ApplicationContext ac =new FileSystemXmlApplicationContext(/User/Desktop/application.xml); ClassPathXmlApplicationContext如果没有前缀默认就是classpath: FileSystemXmlApplicationContext如果没有前缀默认就是 file: Spring容器不仅可以通过xml来初始化，也可以通过@Configuration注解来注册Bean，Spring也提供了相应的AnnotationConfigApplicationContext。 1ApplicationContext context =new AnnotationConfigApplicationContext(Config.class); 其中Config类就是加了@Configuration的类. ###WebApplicationContextWebApplicationContext是Spring专门为web应用准备的，它可以从现对于web根目录的路径中装配文件来完成初始化。WebApplicationContext与ServletContext可以相互获得.在非Web应用的环境下，Bean只有singleton和prototype两种作用域，而WebApplicationContext为Bean添加了三个新的作用域:request,session,global session。 WebApplicationContext和ServletContext是如何相互获取的，其实很简单，在WebApplicationContext里有ServletContext成员变量，直接get就完了。在ServletContext里有一个写死的attrbute，也是直接get..而且Spring提供了一个WebApplicationContextUtils来封装了这个写死的attribute. 1234其实就是直接调用了ServletContext.getAttribute(ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123; return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); &#125; WebApplication的初始化初始化的方式有两种： 在web.xml中配置一个ContextLoaderListener； 配置一个自启动的LoaderServlet 12345678 &lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 不根据xml启动Spring而使用@Configuration类启动 123456789101112 &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.zdy.Configuration&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 配置一个contextClass参数ApplicationContext改为AnnotationConfigWebApplicationContext，然后contextConfigLocation不是指定配置文件xml位置了，改为指定Configuration类的位置。就OK了。 练习来源：我又不是架构师]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring学习二]]></title>
    <url>%2F2019%2F05%2F30%2Fspring%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Spring好处经过昨天的练习学会了使用spring进行IOC，那么今天来思考一下，spring解决了什么问题，又有什么优势呢？ 先来看下一段jdbc程序12345678910//注册驱动DriverManager.registerDriver(new com.mysql.jdbc.Driver());//创建连接Connection connectMySQL = DriverManager.getConnection(“jdbc:mysql://localhost:3306/myuser","root" ,"123" );//获取操作数据库的预处理对象Statement statamentMySQL = connectMySQL.createStatement(); //获得返回结果statement.excuteUpdate( "INSERT INTO student(name, age, sex,address, depart, worklen,wage)" + " VALUES ('Tom1', 321, 'M', 'china','Personnel','3','3000' ) ") ; //释放资源 conn.close(); 那么这段程序有什么问题呢？在第二行的位置注册驱动时，因为直接使用了DriverManager.registerDriver如果程序中没有mysql的包将会直接产生检查型error进行报错。此时类之间的耦合性很高，那么如何能降低依赖呢？解耦的思路： 使用反射来创建对象，而避免使用关键字new； 通过读取配置文件来获取要创建的对象全限定类名； 其实还有一种驱动加载的方式是使用反射 Class.forName(“com.mysql.jdbc.Driver”) ``` 来代替注册驱动的位置，在程序编译时Class.forName参数中的只是字符串并不会产生报错，只有在运行时加载类的时候才会因找不到该类产生异常，由此来降低程序间的依赖。实际开发过程中也应该做到在编译期不依赖，运行时才依赖。12345在传统方式使用中mvc时，使用的是通过接口 = new 具体实现类的方式获得具体对象,并执行方法，这的强依赖和上面的jdbc样例是一样的。```java Car car = new Bus();car.run(); 那么如何能解决眼前的问题呢？工厂模式解耦12345678910111213141516171819202122232425262728//工厂接口public interface Product &#123; void produce();&#125;//汽车接口public class Car implements Product &#123; @Override public void produce() &#123; System.out.println("***制造小汽车***"); &#125;&#125;//电视接口public class Tv implements Product&#123; @Override public void produce() &#123; System.out.println("***制造电视***"); &#125;&#125;//工厂类public static Product produce(String name) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Product product = (Product)Class.forName(className).newInstance(); return product;&#125;//测试类 public static void main(String[] args) &#123; BeanFactory.produce("com.impl.Car").produce(); BeanFactory.produce("com.impl.Tv").produce(); &#125; 执行结果：制造小汽车制造电视Process finished with exit code 0 使用此模式在使用时参数还是需要准确的写出包的路径，并且每次反射都是新建了一个新的对象，在非多线程环境下对资源的消耗是一种浪费。由此对此程序进行优化 创建一个Bean对象工厂 需要一个配置文件来配置加载项( 配置内容：唯一标识 = 全限定类名（KEY ，Value）) 通过读取配置文件中配置的内容，反射创建对象 配置文件既可以是xml 也可以是properties 12345678910111213141516171819202122232425262728293031323334353637383940public class BeanFactory &#123; private static Properties props ; //定义一个map用来存放需要的对象，模拟容器 private static Map&lt;String,Object&gt; beans; //类加载时读取配置文件并加载到容器中 static &#123; InputStream in = null; beans = new HashMap(); props = new Properties(); try &#123; //为防止加载时路径异常使用类加载器获取路径 in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties"); props.load(in); Iterator&lt;String&gt; iterator = props.stringPropertyNames().iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); String value = props.getProperty(key); Object bean = Class.forName(value).newInstance(); beans.put(key, bean); &#125; &#125; catch (IOException e) &#123; throw new ExceptionInInitializerError("初始化失败"); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != in) in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static Product produce(String name) throws ClassNotFoundException,IllegalAccessException, InstantiationException &#123; return (Product) beans.get(name); &#125;&#125; bean.properties内容：12tv=com.impl.Tvcar=com.impl.Car 通过以上方式来模拟了一个容器，实现了应用对资源的解耦，而使用了spring的IOC则完全避免了去实现这些复杂的处理，优雅的实现。”不要给我们打电话，我们会打给你的。”这是著名的好莱坞原则。早先传统的方式通过new 关键字主动创建一个依赖的对象，使用了spring后只需要告诉它需要什么类，剩下的交给它搞定，于是控制反转了Inversion of Control 简称IOC。 代码地址]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习一 IOC、DI]]></title>
    <url>%2F2019%2F05%2F28%2FSpring%E5%AD%A6%E4%B9%A0%E4%B8%80-IOC%E3%80%81DI%2F</url>
    <content type="text"><![CDATA[IOC、DI项目地址基于配置文件的练习1.准备pojo123456789101112131415161718package com.how2java.pojo;public class Category &#123; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private int id; private String name;&#125; 2.配置文件在src目录下新建applicationContext.xml文件applicationContext.xml是Spring的核心配置文件，通过关键字c即可获取Category对象，该对象获取的时候，即被注入了字符串”category 1“到name属性中12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注入对象1.准备pojo1234567891011121314151617181920212223242526package com.how2java.pojo;public class Product &#123; private int id; private String name; private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 2.在applicationContext.xml中注入对象123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.how2java.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt; &lt;property name="category" ref="c" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注解的方式 IOC、DI1.配置applicationContext.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:annotation-config/&gt; &lt;bean name="c" class="com.how2java.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.how2java.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt;&lt;!-- &lt;property name="category" ref="c" /&gt; --&gt; &lt;/bean&gt;&lt;/beans&gt; 2.pojo中加入注解@Autowired1234567891011121314151617181920212223242526package com.how2java.pojo;import org.springframework.beans.factory.annotation.Autowired;public class Product &#123; private int id; private String name; @Autowired private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 除了在属性前加上@Autowired 这种方式外，也可以在setCategory方法前加上@Autowired，这样来达到相同的效果除了@Autowired之外，也可以使用@Resource@Resource和@Autowired注解都是用来实现依赖注入的。只是@Autowired按byType自动注入，而@Resource默认按 byName自动注入。@Resource有两个重要的属性，分是name和type。Spring将name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 在配置了两个bean后使用Autowired因为有两个bean没法指定所以报错，此时可以使用@Resource 来指定加载name是c2那个bean1234567891011//@Resource(name ="c2") @Autowired private Category category; public Category getCategory() &#123; return category; &#125; 错误提示 Could not autowire. There is more than one bean of 'Category' type. Beans: c (applicationContext.xml) c2 (applicationContext.xml) 对Bean的注解1.配置applicationContext.xml只保留]]></content>
      <categories>
        <category>框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSO 单点登陆]]></title>
    <url>%2F2019%2F05%2F26%2FSSO-%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[起源在一个企业发展的过程中，用到的系统会慢慢增多，使用人员在多个系统中操作时需要登录各个系统，而且可能每个系统账号都不一样，这对使用人员来说很不方便，于是就产生了单点登录，在一个系统登录其他的系统就不用登陆。 实现过程在做单点登录之前先来回顾下单系统登录的操作，首先进入系统登录页面，填写登录信息提交表单，系统后台对账号密码进行验证，验证通过就会建立Session ，然后把sessionid通过cookie发送给浏览器，下次再请求系统时cookie会跟着发送过去，此时就已经知道该账号已经登陆了。 那么既然系统A已经登录认证过了，是不是再请求别的系统B时也就认证通过了呢？首先要解决的是session共享问题，系统A认证登录过后在服务器中建立了一个session对应的当前会话，并把sessionId放到了cookie中返回给了浏览器，系统B显然是没有系统A的session的，此时可以使用Redis 把session缓存其中多个系统都共用。 session的问题解决了那么前端的cookie呢？浏览器请求系统A获得的cookie 是不能跨域请求到系统中B的。cookie不能跨域，那么我们可以把这两个系统放到同一域名下，分为不同的二级域名。比如www.abc.OA.com 和www.abc.HR.com 它们的父级域名 www.abc.com。 但是考虑到多个系统架构不同，语言也可能不同，共享session 有点麻烦，且如果是不同域呢？有没有更好的方式呢？此时引入正题，就是由耶鲁大学提出的CAS（Central Authentication Service）一个著名的SSO解决方案。流程如下： 用户访问A系统，验证此用户未登陆。 重定向至cas，cas中也没有登陆，返回登陆页面 填写用户名、密码，cas进行认证后，产生一个Ticket（随机字符串认证用的）将登录状态写入cas的session，返回给浏览器cas下的Cookie，并将将Ticket放入URL中返回（如：www.a.com/pageA?ticket=123） 浏览器被重定向请求系统A，系统A拿着ticket去cas验证是否是伪造的，cas认证通过，在cas中注册系统A创建全局会话，并通知系统A验证通过。 系统A建立session，返回给浏览器系统A的cookie，并把浏览器请求的页面返回。 再次访问A系统另一个受限页面时因为浏览器中已携带该域cookie，则直接返回资源给浏览器。 验证后系统B登陆流程如下： 补充 CAS的SSO实现方式可简化理解为：1个Cookie和N个Session。CAS Server创建cookie，在所有应用认证时使用，各应用通过创建各自的Session来标识用户是否已登录。 ST（Service Ticket） 1、 ST只能使用一次CAS协议规定，无论 Service Ticket验证是否成功， CAS Server都会清除服务端缓存中的该Ticket，从而可以确保一个Service Ticket不被使用两次。 2、 ST在一段时间内失效CAS规定ST只能存活一定的时间，然后CAS Server会让它失效。默认有效时间为5分钟。 3、 ST是基于随机数生成的ST必须足够随机，如果ST生成规则被猜出，Hacker就等于绕过CAS认证，直接访问对应的服务。 码农翻身读后感]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>单点登陆</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2019%2F05%2F26%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[什么是Hexo ?Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。 准备工作相关资料Github 官网Github PagesHexo 官网Node.js 官网Git 官网 相关教程使用 GitHub 和 Hexo 搭建免费静态 Blog简书 搭建个人博客知乎主题配置 常用命令依照上面的连接把准备工作做完了之后来使用下面命令开始博客之旅。 12345678910111213npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客命令简写hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 Markdown 格式 添加标签title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: web前端tags: jQuery 表格 表单验证设置以后点击对应的标签均可连接到当前文章内。 添加文章分类title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: web前端如果在 web前端下方添加-xx 不会产生两个分类，会产生层级的分类，嵌套在上一级分类下。个性化定制添加网易云音乐打开网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器 复制外链的代码修改 blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码 设置背景把你挑选的背景图片命名为：background.jpg，放在blog\themes\next\source\images里，在blog\themes\next\source\css_custom文件的custom.styl首部添加：1234body &#123; background:url(/images/background.jpg); background-attachment: fixed;&#125; background-attachment: fixed;是固定背景图片。 ###踩过的坑域名失效问题每次在执行命令hexo g -d （先生成文件再部署）时，都会使设置好的域名失效。因此需要在生成静态资源的目录（blog/public）底下新建CNAME文件（无后缀名）在其中配置上域名即可。 添加评论，页面不显示关于评论，我选择的是来必力思密达的插件，在配置时Next主题文档提示只需要在主题配置gentie_productKey 配置上来必力的id即可。但是在实际操作时发现页面并没有显示评论窗口，在查看配置文件时（next\layout_partials\comments.swig）发现，加载思密达的插件逻辑是如果没有多说，多言或等等等且gentie_productKey不为空则加载插件，考虑到可能中间可能有哪个评论的配置没有注释掉而没有加载，这里直接偷懒把判断加载思密达插件的逻辑放到了判断的前面，hexo clean、hexo g -d 至此评论区显示成功。配置文件如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% if page.comments %&#125; &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &lt;div class="comments" id="comments"&gt; &lt;div class="ds-thread" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.facebook_sdk.enable and theme.facebook_comments_plugin.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div class="fb-comments" data-href="&#123;&#123; page.permalink &#125;&#125;" data-numposts="&#123;&#123; theme.facebook_comments_plugin.num_of_posts &#125;&#125;" data-width="&#123;&#123; theme.facebook_comments_plugin.width &#125;&#125;" data-colorscheme="&#123;&#123; theme.facebook_comments_plugin.scheme &#125;&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.vkontakte_api.enable and theme.vkontakte_api.comments %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="vk_comments"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.disqus.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="disqus_thread"&gt; &lt;noscript&gt; Please enable JavaScript to view the &lt;a href="https://disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt; &lt;/noscript&gt; &lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.hypercomments_id %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="hypercomments_widget"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.youyan_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="uyan_frame"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="SOHUCS"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.gitment.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表（中）]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[如何设计一个工业级的散列函数？何为一个工业级的散列表？工业级的散列表应该具有哪些特性？1.支持快速的查询、插入、删除操作； 2.内存占用合理，不能浪费过多空间； 3.性能稳定，散列函数生成的值要尽可能的均匀分布，在极端情况下，散列表的性能也不会退化到无法接受的情况。 方案：如何设计这样一个散列表呢？根据前面的知识点，从3个方面来考虑设计思路： 1.设计一个不复杂，散列值尽可能分布均匀的散列函数； 2.定义装载因子阈值，并且设计高效动态扩容策略； 3.选择合适的散列冲突解决方法。 步骤拆分： 一、如何设计散列函数？1.要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。2.除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。3.常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。 二、如何根据装载因子动态扩容？1.如何设置装载因子阈值？ 装载因子越大，说明散列表中的元素越多，空闲的位置就越少，冲突的概率就越大，对于动态的散列表，可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，创建一个更大的散列表将数据迁移到新散列表中,如果每次扩容都是原来大小的两倍，那么扩容后的负载因子就会降为原来的一半。（插入数据的时间复杂度使用摊还分析法，均摊复杂度O(1)） 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。 2.如何避免低效扩容？大部分情况下散列表插入一个数据都很快，但是当负载因子到达阀值，需要进行扩容，再插入数据，再扩容的过程中因为散列表大小进行了改变所以存储的位置也得到了改变，这个时候插入数据就会变得很慢。 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。 分批扩容的查询操作：先查新散列表，再查老散列表。 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。 三、如何选择散列冲突解决方法？常见的2中方法：开放寻址法和链表法。1.链表法对内存的空间利用率更高，链表节点可以在冲突时再创建，并不需要开放寻址法提前将空间申请好。其对大装载因子的容忍度更高。开放寻址适用于装载因子小于1的情景，接近1的时候，就会出现大量的散列冲突，导致大量探测，再散列，性能会下降很多。但是对于链表法来说只要散列函数值均匀，即使装载因子变成了10，也只是链表的长度拉长了，虽然查找效率变慢，但是比顺序查找还是要快很多。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。 2.开放寻址法可以利用CPU缓存加快查询速度但是删除数据比较麻烦，并不能直接删除，需要标记已经删除掉的数据，而且每个冲突的数据都在数组中，冲突的代价很高，装载因子也不能设置的过大，导致了此方法比较浪费内存空间。但是对于小规模数据、装载因子不高的散列表，比较适合用。 四、总结基于链表的散列冲突方法比较适合存储大对象，大数据量的散列表，因为对于大对象而言散列表中存储的指针大小基本可以忽略了，对于比较小的对象存储，是比较消耗内存的。但是比起开放寻址法它更加的灵活，支持更多的优化策略，比如红黑树代替链表。 举例分析1.初始大小Java中的HashMap的默认初始大小是16，可以在预先知道大小时修改默认配置，减少扩容次数。2.装载因子和动态扩容最大装载因子默认是0.75，当元素个数超过了 0.75 * size 的时候，就会启动扩容，每次扩容是原来的两倍。3.散列冲突解决方法HashMap底层使用链表法来解决冲突，负载因子和散列函数设计的再合理也会出现拉链过场的情况，严重影响HashMap的性能。在JDK1.8版本中，引入了红黑树。当链表长度太长（默认为8）时，链表就转化为红黑树。利用红黑树快速增删改查的特点提高性能，在红黑树节点少于8个的时候又将红黑树转化为链表。（在数据量矫情的情况下，红黑树要维护平衡，和链表比起来性能上没什么优势）4.散列函数1234int hash(Object key) &#123; int h = key.hashCode()； return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); //capicity 表示散列表的大小&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表（上）]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、散列表的由来？1.散列表又称Hash Table ,平时也叫它“哈希表”。散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。2.需要存储在散列表中的数据我们称为(key)，将key转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。3.将数据存储在散列值对应的数组下标位置。 二、如何设计散列函数？散列函数的三个基本要求： 1.散列函数计算得到的散列值是一个非负整数。 2.若key1=key2，则hash(key1)=hash(key2) 3.若key≠key2，则hash(key1)≠hash(key2) 对于第三点，在实际场景中因为鸽笼效应（既21只鸽子，20个鸽笼肯定有一个鸽笼有两只鸽子）对应代码问题是数组的大小有限，比如常见的哈希算法取模法。数组的长度是5，这时有一个数据是6。那么如何把这个6存放到长度只有5的数组中呢？按照取模法，计算6％5，结果是1，那么就把6放到数组下标是1的位置。所以在数组大小受限的情况下散列冲突是必然产生的。 三、散列冲突的解放方法？那么既然散列冲突无法避免如何去解决散列冲突呢？常用的散列冲突解决方法有2类：开放寻址法（open addressing）和链表法（chaining） 1.开放寻址法核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。 线性探测法（Linear Probing）：插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到空闲位置，将其插入。查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。删除数据：在查找时如果元素为空则表示不在散列表中，为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。极端情况下需要遍历整个数组所以最坏时间复杂度为O(n) 二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。 双重散列（Double hashing）：不使用一个散列函数而是使用一组散列函数（hash1(),hash2()），先用第一个散列函数，如果得到的存储位置被占用则使用第二个，依次类推，直到找到空闲位置为止。 不管使用什么方法，当散列表空闲位置不多时，散列冲突概率就会很高，为了保证散列表的操作效率，一般情况都会保证散列表有一定比例的空位在此用“装载因子”来表示空位多少。 散列表装载因子=填入表中的个数/散列表的长度。 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 2.链表法（常用）插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。 四、思考1.Word文档中单词拼写检查功能是如何实现的？字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。 2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？遍历 10 万条数据，以 URL 为 key，访问次数为value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果k的数值不大，可使用桶排序，时间复杂度为O(n),如果K的数值较大，就使用快排，时间复杂度为O(NlogN) 3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？先将第一个字符串数组构建一个散列表，key为字符串value为次数。再以第二个字符串数组的值为key遍历，值相同的value+1，最后value大于1的说明有相同字符串。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
